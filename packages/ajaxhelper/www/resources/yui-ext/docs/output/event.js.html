<html><head><title>event.js</title><link rel="stylesheet" type="text/css" href="../resources/style.css" media="screen"/></head><body><h1>event.js</h1><pre class="highlighted"><code><i>/*                                                                                                                                                      
Copyright (c) 2006, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http:<i>//developer.yahoo.net/yui/license.txt</i>
version: 0.12.0
*/</i>
<i>// holder</i>
<i>/**
 * The CustomEvent class lets you define events <b>for</b> your application
 * that can be subscribed to by one or more independent component.
 *
 * @param {String}  type The type of event, which is passed to the callback
 *                  when the event fires
 * @param {Object}  oScope The context the event will fire from.  &quot;<b>this</b>&quot; will
 *                  refer to <b>this</b> object <b>in</b> the callback.  Default value: 
 *                  the window object.  The listener can override <b>this</b>.
 * @param {boolean} silent pass true to prevent the event from writing to
 *                  the log system
 * @namespace YAHOO.util
 * @class CustomEvent
 * @constructor
 */</i>
YAHOO.util.CustomEvent = <b>function</b>(type, oScope, silent, signature) {

    <i>/**
     * The type of event, returned to subscribers when the event fires
     * @property type
     * @type string
     */</i>
    <b>this</b>.type = type;

    <i>/**
     * The scope the the event will fire from by <b>default</b>.  Defaults to the window 
     * obj
     * @property scope
     * @type object
     */</i>
    <b>this</b>.scope = oScope || window;

    <i>/**
     * By <b>default</b> all custom events are logged <b>in</b> the debug build, set silent
     * to true to disable logging <b>for</b> this event.
     * @property silent
     * @type boolean
     */</i>
    <b>this</b>.silent = silent;

    <i>/**
     * Custom events support two styles of arguments provided to the event
     * subscribers.  
     * &lt;ul&gt;
     * &lt;li&gt;YAHOO.util.CustomEvent.LIST: 
     *   &lt;ul&gt;
     *   &lt;li&gt;param1: event name&lt;/li&gt;
     *   &lt;li&gt;param2: array of arguments sent to fire&lt;/li&gt;
     *   &lt;li&gt;param3: &lt;optional&gt; a custom object supplied by the subscriber&lt;/li&gt;
     *   &lt;/ul&gt;
     * &lt;/li&gt;
     * &lt;li&gt;YAHOO.util.CustomEvent.FLAT
     *   &lt;ul&gt;
     *   &lt;li&gt;param1: the first argument passed to fire.  If you need to
     *           pass multiple parameters, use and array or object literal&lt;/li&gt;
     *   &lt;li&gt;param2: &lt;optional&gt; a custom object supplied by the subscriber&lt;/li&gt;
     *   &lt;/ul&gt;
     * &lt;/li&gt;
     * &lt;/ul&gt;
     *   @property signature
     *   @type int
     */</i>
    <b>this</b>.signature = signature || YAHOO.util.CustomEvent.LIST;

    <i>/**
     * The subscribers to <b>this</b> event
     * @property subscribers
     * @type Subscriber[]
     */</i>
    <b>this</b>.subscribers = [];

    <b>if</b> (!<b>this</b>.silent) {
    }

    <b>var</b> onsubscribeType = &quot;_YUICEOnSubscribe&quot;;

    <i>// Only add subscribe events <b>for</b> events that are not generated by </i>
    <i>// CustomEvent</i>
    <b>if</b> (type !== onsubscribeType) {

        <i>/**
         * Custom events provide a custom event that fires whenever there is
         * a <b>new</b> subscriber to the event.  This provides an opportunity to
         * handle the <b>case</b> where there is a non-repeating event that has
         * already fired has a <b>new</b> subscriber.  
         *
         * @event subscribeEvent
         * @type YAHOO.util.CustomEvent
         * @param {Function} fn The <b>function</b> to execute
         * @param {Object}   obj An object to be passed along when the event 
         *                       fires
         * @param {boolean|Object}  override If true, the obj passed <b>in</b> becomes 
         *                                   the execution scope of the listener.
         *                                   <b>if</b> an object, that object becomes the
         *                                   the execution scope.
         */</i>
        <b>this</b>.subscribeEvent = 
                <b>new</b> YAHOO.util.CustomEvent(onsubscribeType, <b>this</b>, true);

    } 
};

<i>/**
 * Subscriber listener sigature constant.  The LIST type returns three
 * parameters: the event type, the array of args passed to fire, and
 * the optional custom object
 * @property YAHOO.util.CustomEvent.LIST
 * @static
 * @type int
 */</i>
YAHOO.util.CustomEvent.LIST = 0;

<i>/**
 * Subscriber listener sigature constant.  The FLAT type returns two
 * parameters: the first argument passed to fire and the optional 
 * custom object
 * @property YAHOO.util.CustomEvent.FLAT
 * @static
 * @type int
 */</i>
YAHOO.util.CustomEvent.FLAT = 1;

YAHOO.util.CustomEvent.prototype = {

    <i>/**
     * Subscribes the caller to <b>this</b> event
     * @method subscribe
     * @param {Function} fn        The <b>function</b> to execute
     * @param {Object}   obj       An object to be passed along when the event 
     *                             fires
     * @param {boolean|Object}  override If true, the obj passed <b>in</b> becomes 
     *                                   the execution scope of the listener.
     *                                   <b>if</b> an object, that object becomes the
     *                                   the execution scope.
     */</i>
    subscribe: <b>function</b>(fn, obj, override) {
        <b>if</b> (<b>this</b>.subscribeEvent) {
            <b>this</b>.subscribeEvent.fire(fn, obj, override);
        }

        <b>this</b>.subscribers.push( <b>new</b> YAHOO.util.Subscriber(fn, obj, override) );
    },

    <i>/**
     * Unsubscribes the caller from <b>this</b> event
     * @method unsubscribe
     * @param {Function} fn  The <b>function</b> to execute
     * @param {Object}   obj  The custom object passed to subscribe (optional)
     * @<b>return</b> {boolean} True <b>if</b> the subscriber was found and detached.
     */</i>
    unsubscribe: <b>function</b>(fn, obj) {
        <b>var</b> found = false;
        <b>for</b> (<b>var</b> i=0, len=<b>this</b>.subscribers.length; i&lt;len; ++i) {
            <b>var</b> s = <b>this</b>.subscribers[i];
            <b>if</b> (s &amp;&amp; s.contains(fn, obj)) {
                <b>this</b>._delete(i);
                found = true;
            }
        }

        <b>return</b> found;
    },

    <i>/**
     * Notifies the subscribers.  The callback functions will be executed
     * from the scope specified when the event was created, and <b>with</b> the 
     * following parameters:
     *   &lt;ul&gt;
     *   &lt;li&gt;The type of event&lt;/li&gt;
     *   &lt;li&gt;All of the arguments fire() was executed <b>with</b> as an array&lt;/li&gt;
     *   &lt;li&gt;The custom object (<b>if</b> any) that was passed into the subscribe() 
     *       method&lt;/li&gt;
     *   &lt;/ul&gt;
     * @method fire 
     * @param {Object*} arguments an arbitrary set of parameters to pass to 
     *                            the handler.
     */</i>
    fire: <b>function</b>() {
        <b>var</b> len=<b>this</b>.subscribers.length;
        <b>if</b> (!len &amp;&amp; <b>this</b>.silent) {
            <b>return</b> true;
        }

        <b>var</b> args=[], ret=true, i;

        <b>for</b> (i=0; i&lt;arguments.length; ++i) {
            args.push(arguments[i]);
        }

        <b>var</b> argslength = args.length;

        <b>if</b> (!<b>this</b>.silent) {
        }

        <b>for</b> (i=0; i&lt;len; ++i) {
            <b>var</b> s = <b>this</b>.subscribers[i];
            <b>if</b> (s) {
                <b>if</b> (!<b>this</b>.silent) {
                }

                <b>var</b> scope = s.getScope(<b>this</b>.scope);

                <b>if</b> (<b>this</b>.signature == YAHOO.util.CustomEvent.FLAT) {
                    <b>var</b> param = null;
                    <b>if</b> (args.length &gt; 0) {
                        param = args[0];
                    }
                    ret = s.fn.call(scope, param, s.obj);
                } <b>else</b> {
                    ret = s.fn.call(scope, <b>this</b>.type, args, s.obj);
                }
                <b>if</b> (false === ret) {
                    <b>if</b> (!<b>this</b>.silent) {
                    }

                    <i>//<b>break</b>;</i>
                    <b>return</b> false;
                }
            }
        }

        <b>return</b> true;
    },

    <i>/**
     * Removes all listeners
     * @method unsubscribeAll
     */</i>
    unsubscribeAll: <b>function</b>() {
        <b>for</b> (<b>var</b> i=0, len=<b>this</b>.subscribers.length; i&lt;len; ++i) {
            <b>this</b>._delete(len - 1 - i);
        }
    },

    <i>/**
     * @method _delete
     * @private
     */</i>
    _delete: <b>function</b>(index) {
        <b>var</b> s = <b>this</b>.subscribers[index];
        <b>if</b> (s) {
            <b>delete</b> s.fn;
            <b>delete</b> s.obj;
        }

        <i>// <b>delete</b> this.subscribers[index];</i>
        <b>this</b>.subscribers.splice(index, 1);
    },

    <i>/**
     * @method toString
     */</i>
    toString: <b>function</b>() {
         <b>return</b> &quot;CustomEvent: &quot; + &quot;'&quot; + <b>this</b>.type  + &quot;', &quot; + 
             &quot;scope: &quot; + <b>this</b>.scope;

    }
};

<i>/////////////////////////////////////////////////////////////////////</i>

<i>/**
 * Stores the subscriber information to be used when the event fires.
 * @param {Function} fn       The <b>function</b> to execute
 * @param {Object}   obj      An object to be passed along when the event fires
 * @param {boolean}  override If true, the obj passed <b>in</b> becomes the execution
 *                            scope of the listener
 * @class Subscriber
 * @constructor
 */</i>
YAHOO.util.Subscriber = <b>function</b>(fn, obj, override) {

    <i>/**
     * The callback that will be execute when the event fires
     * @property fn
     * @type <b>function</b>
     */</i>
    <b>this</b>.fn = fn;

    <i>/**
     * An optional custom object that will passed to the callback when
     * the event fires
     * @property obj
     * @type object
     */</i>
    <b>this</b>.obj = obj || null;

    <i>/**
     * The <b>default</b> execution scope <b>for</b> the event listener is defined when the
     * event is created (usually the object which contains the event).
     * By setting override to true, the execution scope becomes the custom
     * object passed <b>in</b> by the subscriber.  If override is an object, that 
     * object becomes the scope.
     * @property override
     * @type boolean|object
     */</i>
    <b>this</b>.override = override;

};

<i>/**
 * Returns the execution scope <b>for</b> this listener.  If override was set to true
 * the custom obj will be the scope.  If override is an object, that is the
 * scope, otherwise the <b>default</b> scope will be used.
 * @method getScope
 * @param {Object} defaultScope the scope to use <b>if</b> this listener does not
 *                              override it.
 */</i>
YAHOO.util.Subscriber.prototype.getScope = <b>function</b>(defaultScope) {
    <b>if</b> (<b>this</b>.override) {
        <b>if</b> (<b>this</b>.override === true) {
            <b>return</b> this.obj;
        } <b>else</b> {
            <b>return</b> this.override;
        }
    }
    <b>return</b> defaultScope;
};

<i>/**
 * Returns true <b>if</b> the fn and obj match <b>this</b> objects properties.
 * Used by the unsubscribe method to match the right subscriber.
 *
 * @method contains
 * @param {Function} fn the <b>function</b> to execute
 * @param {Object} obj an object to be passed along when the event fires
 * @<b>return</b> {boolean} true <b>if</b> the supplied arguments match <b>this</b> 
 *                   subscriber's signature.
 */</i>
YAHOO.util.Subscriber.prototype.contains = <b>function</b>(fn, obj) {
    <b>if</b> (obj) {
        <b>return</b> (<b>this</b>.fn == fn &amp;&amp; <b>this</b>.obj == obj);
    } <b>else</b> {
        <b>return</b> (<b>this</b>.fn == fn);
    }
};

<i>/**
 * @method toString
 */</i>
YAHOO.util.Subscriber.prototype.toString = <b>function</b>() {
    <b>return</b> &quot;Subscriber { obj: &quot; + (<b>this</b>.obj || &quot;&quot;)  + 
           &quot;, override: &quot; +  (<b>this</b>.override || &quot;no&quot;) + &quot; }&quot;;
};

<i>/**
 * The Event Utility provides utilities <b>for</b> managing DOM Events and tools
 * <b>for</b> building event systems
 *
 * @module event
 * @title Event Utility
 * @namespace YAHOO.util
 * @requires yahoo
 */</i>

<i>// The first instance of Event will win <b>if</b> it is loaded more than once.</i>
<b>if</b> (!YAHOO.util.Event) {

<i>/**
 * The event utility provides functions to add and remove event listeners,
 * event cleansing.  It also tries to automatically remove listeners it
 * registers during the unload event.
 *
 * @class Event
 * @static
 */</i>
    YAHOO.util.Event = <b>function</b>() {

        <i>/**
         * True after the onload event has fired
         * @property loadComplete
         * @type boolean
         * @static
         * @private
         */</i>
        <b>var</b> loadComplete =  false;

        <i>/**
         * Cache of wrapped listeners
         * @property listeners
         * @type array
         * @static
         * @private
         */</i>
        <b>var</b> listeners = [];

        <i>/**
         * User-defined unload <b>function</b> that will be fired before all events
         * are detached
         * @property unloadListeners
         * @type array
         * @static
         * @private
         */</i>
        <b>var</b> unloadListeners = [];

        <i>/**
         * Cache of DOM0 event handlers to work around issues <b>with</b> DOM2 events
         * <b>in</b> Safari
         * @property legacyEvents
         * @static
         * @private
         */</i>
        <b>var</b> legacyEvents = [];

        <i>/**
         * Listener stack <b>for</b> DOM0 events
         * @property legacyHandlers
         * @static
         * @private
         */</i>
        <b>var</b> legacyHandlers = [];

        <i>/**
         * The number of times to poll after window.onload.  This number is
         * increased <b>if</b> additional late-bound handlers are requested after
         * the page load.
         * @property retryCount
         * @static
         * @private
         */</i>
        <b>var</b> retryCount = 0;

        <i>/**
         * onAvailable listeners
         * @property onAvailStack
         * @static
         * @private
         */</i>
        <b>var</b> onAvailStack = [];

        <i>/**
         * Lookup table <b>for</b> legacy events
         * @property legacyMap
         * @static
         * @private
         */</i>
        <b>var</b> legacyMap = [];

        <i>/**
         * Counter <b>for</b> auto id generation
         * @property counter
         * @static
         * @private
         */</i>
        <b>var</b> counter = 0;

        <b>return</b> { <i>// PREPROCESS</i>

            <i>/**
             * The number of times we should look <b>for</b> elements that are not
             * <b>in</b> the DOM at the time the event is requested after the document
             * has been loaded.  The <b>default</b> is 200@amp;50 ms, so it will poll
             * <b>for</b> 10 seconds or until all outstanding handlers are bound
             * (whichever comes first).
             * @property POLL_RETRYS
             * @type int
             * @static
             * @final
             */</i>
            POLL_RETRYS: 200,

            <i>/**
             * The poll interval <b>in</b> milliseconds
             * @property POLL_INTERVAL
             * @type int
             * @static
             * @final
             */</i>
            POLL_INTERVAL: 20,

            <i>/**
             * Element to bind, int constant
             * @property EL
             * @type int
             * @static
             * @final
             */</i>
            EL: 0,

            <i>/**
             * Type of event, int constant
             * @property TYPE
             * @type int
             * @static
             * @final
             */</i>
            TYPE: 1,

            <i>/**
             * Function to execute, int constant
             * @property FN
             * @type int
             * @static
             * @final
             */</i>
            FN: 2,

            <i>/**
             * Function wrapped <b>for</b> scope correction and cleanup, int constant
             * @property WFN
             * @type int
             * @static
             * @final
             */</i>
            WFN: 3,

            <i>/**
             * Object passed <b>in</b> by the user that will be returned as a 
             * parameter to the callback, int constant
             * @property OBJ
             * @type int
             * @static
             * @final
             */</i>
            OBJ: 3,

            <i>/**
             * Adjusted scope, either the element we are registering the event
             * on or the custom object passed <b>in</b> by the listener, int constant
             * @property ADJ_SCOPE
             * @type int
             * @static
             * @final
             */</i>
            ADJ_SCOPE: 4,

            <i>/**
             * Safari detection is necessary to work around the preventDefault
             * bug that makes it so you can't cancel a href click from the 
             * handler.  There is not a capabilities check we can use here.
             * @property isSafari
             * @private
             * @static
             */</i>
            isSafari: (/Safari|Konqueror|KHTML/gi).test(navigator.userAgent),

            <i>/**
             * IE detection needed to properly calculate pageX and pageY.  
             * capabilities checking didn't seem to work because another 
             * browser that does not provide the properties have the values 
             * calculated <b>in</b> a different manner than IE.
             * @property isIE
             * @private
             * @static
             */</i>
            isIE: (!<b>this</b>.isSafari &amp;&amp; !navigator.userAgent.match(/opera/gi) &amp;&amp; 
                    navigator.userAgent.match(/msie/gi)),

            <i>/**
             * poll handle
             * @property _interval
             * @private
             */</i>
            _interval: null,

            <i>/**
             * @method startInterval
             * @static
             * @private
             */</i>
            startInterval: <b>function</b>() {
                <b>if</b> (!<b>this</b>._interval) {
                    <b>var</b> self = <b>this</b>;
                    <b>var</b> callback = <b>function</b>() { self._tryPreloadAttach(); };
                    <b>this</b>._interval = setInterval(callback, <b>this</b>.POLL_INTERVAL);
                    <i>// <b>this</b>.timeout = setTimeout(callback, i);</i>
                }
            },

            <i>/**
             * Executes the supplied callback when the item <b>with</b> the supplied
             * id is found.  This is meant to be used to execute behavior as
             * soon as possible as the page loads.  If you use <b>this</b> after the
             * initial page load it will poll <b>for</b> a fixed time <b>for</b> the element.
             * The number of times it will poll and the frequency are
             * configurable.  By <b>default</b> it will poll <b>for</b> 10 seconds.
             *
             * @method onAvailable
             *
             * @param {string}   p_id the id of the element to look <b>for</b>.
             * @param {<b>function</b>} p_fn what to execute when the element is found.
             * @param {object}   p_obj an optional object to be passed back as
             *                   a parameter to p_fn.
             * @param {boolean}  p_override If set to true, p_fn will execute
             *                   <b>in</b> the scope of p_obj
             *
             * @static
             */</i>
            onAvailable: <b>function</b>(p_id, p_fn, p_obj, p_override) {
                onAvailStack.push( { id:         p_id, 
                                     fn:         p_fn, 
                                     obj:        p_obj, 
                                     override:   p_override, 
                                     checkReady: false    } );

                retryCount = <b>this</b>.POLL_RETRYS;
                <b>this</b>.startInterval();
            },

            <i>/**
             * Works the same way as onAvailable, but additionally checks the
             * state of sibling elements to determine <b>if</b> the content of the
             * available element is safe to modify.
             *
             * @method onContentReady
             *
             * @param {string}   p_id the id of the element to look <b>for</b>.
             * @param {<b>function</b>} p_fn what to execute when the element is ready.
             * @param {object}   p_obj an optional object to be passed back as
             *                   a parameter to p_fn.
             * @param {boolean}  p_override If set to true, p_fn will execute
             *                   <b>in</b> the scope of p_obj
             *
             * @static
             */</i>
            onContentReady: <b>function</b>(p_id, p_fn, p_obj, p_override) {
                onAvailStack.push( { id:         p_id, 
                                     fn:         p_fn, 
                                     obj:        p_obj, 
                                     override:   p_override,
                                     checkReady: true      } );

                retryCount = <b>this</b>.POLL_RETRYS;
                <b>this</b>.startInterval();
            },

            <i>/**
             * Appends an event handler
             *
             * @method addListener
             *
             * @param {Object}   el        The html element to assign the 
             *                             event to
             * @param {String}   sType     The type of event to append
             * @param {Function} fn        The method the event invokes
             * @param {Object}   obj    An arbitrary object that will be 
             *                             passed as a parameter to the handler
             * @param {boolean}  override  If true, the obj passed <b>in</b> becomes
             *                             the execution scope of the listener
             * @<b>return</b> {boolean} True <b>if</b> the action was successful or defered,
             *                        false <b>if</b> one or more of the elements 
             *                        could not have the event bound to it.
             * @static
             */</i>
            addListener: <b>function</b>(el, sType, fn, obj, override) {

                <b>if</b> (!fn || !fn.call) {
                    <b>return</b> false;
                }

                <i>// The el argument can be an array of elements or element ids.</i>
                <b>if</b> ( <b>this</b>._isValidCollection(el)) {
                    <b>var</b> ok = true;
                    <b>for</b> (<b>var</b> i=0,len=el.length; i&lt;len; ++i) {
                        ok = <b>this</b>.on(el[i], 
                                       sType, 
                                       fn, 
                                       obj, 
                                       override) &amp;&amp; ok;
                    }
                    <b>return</b> ok;

                } <b>else</b> if (<b>typeof</b> el == &quot;string&quot;) {
                    <b>var</b> oEl = <b>this</b>.getEl(el);
                    <i>// If the el argument is a string, we assume it is </i>
                    <i>// actually the id of the element.  If the page is loaded</i>
                    <i>// we convert el to the actual element, otherwise we </i>
                    <i>// defer attaching the event until onload event fires</i>

                    <i>// check to see <b>if</b> we need to delay hooking up the event </i>
                    <i>// until after the page loads.</i>
                    <b>if</b> (oEl) {
                        el = oEl;
                    } <b>else</b> {
                        <i>// defer adding the event until the element is available</i>
                        <b>this</b>.onAvailable(el, <b>function</b>() {
                           YAHOO.util.Event.on(el, sType, fn, obj, override);
                        });

                        <b>return</b> true;
                    }
                }

                <i>// Element should be an html element or an array <b>if</b> we get </i>
                <i>// here.</i>
                <b>if</b> (!el) {
                    <b>return</b> false;
                }

                <i>// we need to make sure we fire registered unload events </i>
                <i>// prior to automatically unhooking them.  So we hang on to </i>
                <i>// these instead of attaching them to the window and fire the</i>
                <i>// handles explicitly during our one unload event.</i>
                <b>if</b> (&quot;unload&quot; == sType &amp;&amp; obj !== <b>this</b>) {
                    unloadListeners[unloadListeners.length] =
                            [el, sType, fn, obj, override];
                    <b>return</b> true;
                }

                <i>// <b>if</b> the user chooses to override the scope, we use the custom</i>
                <i>// object passed <b>in</b>, otherwise the executing scope will be the</i>
                <i>// HTML element that the event is registered on</i>
                <b>var</b> scope = el;
                <b>if</b> (override) {
                    <b>if</b> (override === true) {
                        scope = obj;
                    } <b>else</b> {
                        scope = override;
                    }
                }

                <i>// wrap the <b>function</b> so we can <b>return</b> the obj object when</i>
                <i>// the event fires;</i>
                <b>var</b> wrappedFn = <b>function</b>(e) {
                        <b>return</b> fn.call(scope, YAHOO.util.Event.getEvent(e), 
                                obj);
                    };

                <b>var</b> li = [el, sType, fn, wrappedFn, scope];
                <b>var</b> index = listeners.length;
                <i>// cache the listener so we can try to automatically unload</i>
                listeners[index] = li;

                <b>if</b> (<b>this</b>.useLegacyEvent(el, sType)) {
                    <b>var</b> legacyIndex = <b>this</b>.getLegacyIndex(el, sType);

                    <i>// Add a <b>new</b> dom0 wrapper <b>if</b> one is not detected <b>for</b> this</i>
                    <i>// element</i>
                    <b>if</b> ( legacyIndex == -1 || 
                                el != legacyEvents[legacyIndex][0] ) {

                        legacyIndex = legacyEvents.length;
                        legacyMap[el.id + sType] = legacyIndex;

                        <i>// cache the signature <b>for</b> the DOM0 event, and </i>
                        <i>// include the existing handler <b>for</b> the event, <b>if</b> any</i>
                        legacyEvents[legacyIndex] = 
                            [el, sType, el[&quot;on&quot; + sType]];
                        legacyHandlers[legacyIndex] = [];

                        el[&quot;on&quot; + sType] = 
                            <b>function</b>(e) {
                                YAHOO.util.Event.fireLegacyEvent(
                                    YAHOO.util.Event.getEvent(e), legacyIndex);
                            };
                    }

                    <i>// add a reference to the wrapped listener to our custom</i>
                    <i>// stack of events</i>
                    <i>//legacyHandlers[legacyIndex].push(index);</i>
                    legacyHandlers[legacyIndex].push(li);

                } <b>else</b> {
                    <b>this</b>._simpleAdd(el, sType, wrappedFn, false);
                }

                <b>return</b> true;
                
            },

            <i>/**
             * When using legacy events, the handler is routed to <b>this</b> object
             * so we can fire our custom listener stack.
             * @method fireLegacyEvent
             * @static
             * @private
             */</i>
            fireLegacyEvent: <b>function</b>(e, legacyIndex) {
                <b>var</b> ok = true;

                <b>var</b> le = legacyHandlers[legacyIndex];
                <b>for</b> (<b>var</b> i=0,len=le.length; i&lt;len; ++i) {
                    <b>var</b> li = le[i];
                    <b>if</b> ( li &amp;&amp; li[<b>this</b>.WFN] ) {
                        <b>var</b> scope = li[<b>this</b>.ADJ_SCOPE];
                        <b>var</b> ret = li[<b>this</b>.WFN].call(scope, e);
                        ok = (ok &amp;&amp; ret);
                    }
                }

                <b>return</b> ok;
            },

            <i>/**
             * Returns the legacy event index that matches the supplied 
             * signature
             * @method getLegacyIndex
             * @static
             * @private
             */</i>
            getLegacyIndex: <b>function</b>(el, sType) {
                <b>var</b> key = <b>this</b>.generateId(el) + sType;
                <b>if</b> (<b>typeof</b> legacyMap[key] == &quot;undefined&quot;) { 
                    <b>return</b> -1;
                } <b>else</b> {
                    <b>return</b> legacyMap[key];
                }
            },

            <i>/**
             * Logic that determines when we should automatically use legacy
             * events instead of DOM2 events.
             * @method useLegacyEvent
             * @static
             * @private
             */</i>
            useLegacyEvent: <b>function</b>(el, sType) {
                <b>if</b> (!el.addEventListener &amp;&amp; !el.attachEvent) {
                    <b>return</b> true;
                } <b>else</b> if (<b>this</b>.isSafari) {
                    <b>if</b> (&quot;click&quot; == sType || &quot;dblclick&quot; == sType) {
                        <b>return</b> true;
                    }
                }
                <b>return</b> false;
            },
                    
            <i>/**
             * Removes an event handler
             *
             * @method removeListener
             *
             * @param {Object} el the html element or the id of the element to 
             * assign the event to.
             * @param {String} sType the type of event to remove.
             * @param {Function} fn the method the event invokes.  If fn is
             * undefined, then all event handlers <b>for</b> the type of event are 
             * removed.
             * @<b>return</b> {boolean} true <b>if</b> the unbind was successful, false 
             * otherwise.
             * @static
             */</i>
            removeListener: <b>function</b>(el, sType, fn) {
                <b>var</b> i, len;

                <i>// The el argument can be a string</i>
                <b>if</b> (<b>typeof</b> el == &quot;string&quot;) {
                    el = <b>this</b>.getEl(el);
                <i>// The el argument can be an array of elements or element ids.</i>
                } <b>else</b> if ( <b>this</b>._isValidCollection(el)) {
                    <b>var</b> ok = true;
                    <b>for</b> (i=0,len=el.length; i&lt;len; ++i) {
                        ok = ( <b>this</b>.removeListener(el[i], sType, fn) &amp;&amp; ok );
                    }
                    <b>return</b> ok;
                }

                <b>if</b> (!fn || !fn.call) {
                    <i>//<b>return</b> false;</i>
                    <b>return</b> this.purgeElement(el, false, sType);
                }

                <b>if</b> (&quot;unload&quot; == sType) {

                    <b>for</b> (i=0, len=unloadListeners.length; i&lt;len; i++) {
                        <b>var</b> li = unloadListeners[i];
                        <b>if</b> (li &amp;&amp; 
                            li[0] == el &amp;&amp; 
                            li[1] == sType &amp;&amp; 
                            li[2] == fn) {
                                unloadListeners.splice(i, 1);
                                <b>return</b> true;
                        }
                    }

                    <b>return</b> false;
                }

                <b>var</b> cacheItem = null;

                <i>// The index is a hidden parameter; needed to remove it from</i>
                <i>// the method signature because it was tempting users to</i>
                <i>// try and take advantage of it, which is not possible.</i>
                <b>var</b> index = arguments[3];
  
                <b>if</b> (&quot;undefined&quot; == <b>typeof</b> index) {
                    index = <b>this</b>._getCacheIndex(el, sType, fn);
                }

                <b>if</b> (index &gt;= 0) {
                    cacheItem = listeners[index];
                }

                <b>if</b> (!el || !cacheItem) {
                    <b>return</b> false;
                }

                <b>if</b> (<b>this</b>.useLegacyEvent(el, sType)) {
                    <b>var</b> legacyIndex = <b>this</b>.getLegacyIndex(el, sType);
                    <b>var</b> llist = legacyHandlers[legacyIndex];
                    <b>if</b> (llist) {
                        <b>for</b> (i=0, len=llist.length; i&lt;len; ++i) {
                            li = llist[i];
                            <b>if</b> (li &amp;&amp; 
                                li[<b>this</b>.EL] == el &amp;&amp; 
                                li[<b>this</b>.TYPE] == sType &amp;&amp; 
                                li[<b>this</b>.FN] == fn) {
                                    llist.splice(i, 1);
                                    <b>break</b>;
                            }
                        }
                    }

                } <b>else</b> {
                    <b>this</b>._simpleRemove(el, sType, cacheItem[<b>this</b>.WFN], false);
                }

                <i>// removed the wrapped handler</i>
                <b>delete</b> listeners[index][<b>this</b>.WFN];
                <b>delete</b> listeners[index][<b>this</b>.FN];
                listeners.splice(index, 1);

                <b>return</b> true;

            },

            <i>/**
             * Returns the event's target element
             * @method getTarget
             * @param {Event} ev the event
             * @param {boolean} resolveTextNode when set to true the target's
             *                  parent will be returned <b>if</b> the target is a 
             *                  text node.  @deprecated, the text node is
             *                  now resolved automatically
             * @<b>return</b> {HTMLElement} the event's target
             * @static
             */</i>
            getTarget: <b>function</b>(ev, resolveTextNode) {
                <b>var</b> t = ev.target || ev.srcElement;
                <b>return</b> this.resolveTextNode(t);
            },

            <i>/**
             * In some cases, some browsers will <b>return</b> a text node inside
             * the actual element that was targeted.  This normalizes the
             * <b>return</b> value <b>for</b> getTarget and getRelatedTarget.
             * @method resolveTextNode
             * @param {HTMLElement} node node to resolve
             * @<b>return</b> {HTMLElement} the normized node
             * @static
             */</i>
            resolveTextNode: <b>function</b>(node) {
                <i>// <b>if</b> (node &amp;&amp; node.nodeName &amp;&amp; </i>
                        <i>// &quot;#TEXT&quot; == node.nodeName.toUpperCase()) {</i>
                <b>if</b> (node &amp;&amp; 3 == node.nodeType) {
                    <b>return</b> node.parentNode;
                } <b>else</b> {
                    <b>return</b> node;
                }
            },

            <i>/**
             * Returns the event's pageX
             * @method getPageX
             * @param {Event} ev the event
             * @<b>return</b> {int} the event's pageX
             * @static
             */</i>
            getPageX: <b>function</b>(ev) {
                <b>var</b> x = ev.pageX;
                <b>if</b> (!x &amp;&amp; 0 !== x) {
                    x = ev.clientX || 0;

                    <b>if</b> ( <b>this</b>.isIE ) {
                        x += <b>this</b>._getScrollLeft();
                    }
                }

                <b>return</b> x;
            },

            <i>/**
             * Returns the event's pageY
             * @method getPageY
             * @param {Event} ev the event
             * @<b>return</b> {int} the event's pageY
             * @static
             */</i>
            getPageY: <b>function</b>(ev) {
                <b>var</b> y = ev.pageY;
                <b>if</b> (!y &amp;&amp; 0 !== y) {
                    y = ev.clientY || 0;

                    <b>if</b> ( <b>this</b>.isIE ) {
                        y += <b>this</b>._getScrollTop();
                    }
                }

                <b>return</b> y;
            },

            <i>/**
             * Returns the pageX and pageY properties as an indexed array.
             * @method getXY
             * @type int[]
             * @static
             */</i>
            getXY: <b>function</b>(ev) {
                <b>return</b> [<b>this</b>.getPageX(ev), <b>this</b>.getPageY(ev)];
            },

            <i>/**
             * Returns the event's related target 
             * @method getRelatedTarget
             * @param {Event} ev the event
             * @<b>return</b> {HTMLElement} the event's relatedTarget
             * @static
             */</i>
            getRelatedTarget: <b>function</b>(ev) {
                <b>var</b> t = ev.relatedTarget;
                <b>if</b> (!t) {
                    <b>if</b> (ev.type == &quot;mouseout&quot;) {
                        t = ev.toElement;
                    } <b>else</b> if (ev.type == &quot;mouseover&quot;) {
                        t = ev.fromElement;
                    }
                }

                <b>return</b> this.resolveTextNode(t);
            },

            <i>/**
             * Returns the time of the event.  If the time is not included, the
             * event is modified using the current time.
             * @method getTime
             * @param {Event} ev the event
             * @<b>return</b> {Date} the time of the event
             * @static
             */</i>
            getTime: <b>function</b>(ev) {
                <b>if</b> (!ev.time) {
                    <b>var</b> t = <b>new</b> Date().getTime();
                    try {
                        ev.time = t;
                    } catch(e) { 
                        <b>return</b> t;
                    }
                }

                <b>return</b> ev.time;
            },

            <i>/**
             * Convenience method <b>for</b> stopPropagation + preventDefault
             * @method stopEvent
             * @param {Event} ev the event
             * @static
             */</i>
            stopEvent: <b>function</b>(ev) {
                <b>this</b>.stopPropagation(ev);
                <b>this</b>.preventDefault(ev);
            },

            <i>/**
             * Stops event propagation
             * @method stopPropagation
             * @param {Event} ev the event
             * @static
             */</i>
            stopPropagation: <b>function</b>(ev) {
                <b>if</b> (ev.stopPropagation) {
                    ev.stopPropagation();
                } <b>else</b> {
                    ev.cancelBubble = true;
                }
            },

            <i>/**
             * Prevents the <b>default</b> behavior of the event
             * @method preventDefault
             * @param {Event} ev the event
             * @static
             */</i>
            preventDefault: <b>function</b>(ev) {
                <b>if</b> (ev.preventDefault) {
                    ev.preventDefault();
                } <b>else</b> {
                    ev.returnValue = false;
                }
            },
             
            <i>/**
             * Finds the event <b>in</b> the window object, the caller's arguments, or
             * <b>in</b> the arguments of another method <b>in</b> the callstack.  This is
             * executed automatically <b>for</b> events registered through the event
             * manager, so the implementer should not normally need to execute
             * <b>this</b> function at all.
             * @method getEvent
             * @param {Event} e the event parameter from the handler
             * @<b>return</b> {Event} the event 
             * @static
             */</i>
            getEvent: <b>function</b>(e) {
                <b>var</b> ev = e || window.event;

                <b>if</b> (!ev) {
                    <b>var</b> c = <b>this</b>.getEvent.caller;
                    <b>while</b> (c) {
                        ev = c.arguments[0];
                        <b>if</b> (ev &amp;&amp; Event == ev.constructor) {
                            <b>break</b>;
                        }
                        c = c.caller;
                    }
                }

                <b>return</b> ev;
            },

            <i>/**
             * Returns the charcode <b>for</b> an event
             * @method getCharCode
             * @param {Event} ev the event
             * @<b>return</b> {int} the event's charCode
             * @static
             */</i>
            getCharCode: <b>function</b>(ev) {
                <b>return</b> ev.charCode || ev.keyCode || 0;
            },

            <i>/**
             * Locating the saved event handler data by <b>function</b> ref
             *
             * @method _getCacheIndex
             * @static
             * @private
             */</i>
            _getCacheIndex: <b>function</b>(el, sType, fn) {
                <b>for</b> (<b>var</b> i=0,len=listeners.length; i&lt;len; ++i) {
                    <b>var</b> li = listeners[i];
                    <b>if</b> ( li                 &amp;&amp; 
                         li[<b>this</b>.FN] == fn  &amp;&amp; 
                         li[<b>this</b>.EL] == el  &amp;&amp; 
                         li[<b>this</b>.TYPE] == sType ) {
                        <b>return</b> i;
                    }
                }

                <b>return</b> -1;
            },

            <i>/**
             * Generates an unique ID <b>for</b> the element <b>if</b> it does not already 
             * have one.
             * @method generateId
             * @param el the element to create the id <b>for</b>
             * @<b>return</b> {string} the resulting id of the element
             * @static
             */</i>
            generateId: <b>function</b>(el) {
                <b>var</b> id = el.id;

                <b>if</b> (!id) {
                    id = &quot;yuievtautoid-&quot; + counter;
                    ++counter;
                    el.id = id;
                }

                <b>return</b> id;
            },

            <i>/**
             * We want to be able to use getElementsByTagName as a collection
             * to attach a group of events to.  Unfortunately, different 
             * browsers <b>return</b> different types of collections.  This <b>function</b>
             * tests to determine <b>if</b> the object is array-like.  It will also 
             * fail <b>if</b> the object is an array, but is empty.
             * @method _isValidCollection
             * @param o the object to test
             * @<b>return</b> {boolean} true <b>if</b> the object is array-like and populated
             * @static
             * @private
             */</i>
            _isValidCollection: <b>function</b>(o) {
                <i>// <b>this</b>.logger.debug(o.constructor.toString())</i>
                <i>// <b>this</b>.logger.debug(<b>typeof</b> o)</i>

                <b>return</b> ( o                    &amp;&amp; <i>// o is something</i>
                         o.length             &amp;&amp; <i>// o is indexed</i>
                         <b>typeof</b> o != &quot;string&quot; &amp;&amp; <i>// o is not a string</i>
                         !o.tagName           &amp;&amp; <i>// o is not an HTML element</i>
                         !o.alert             &amp;&amp; <i>// o is not a window</i>
                         <b>typeof</b> o[0] != &quot;undefined&quot; );

            },

            <i>/**
             * @private
             * @property elCache
             * DOM element cache
             * @static
             */</i>
            elCache: {},

            <i>/**
             * We cache elements bound by id because when the unload event 
             * fires, we can no longer use document.getElementById
             * @method getEl
             * @static
             * @private
             */</i>
            getEl: <b>function</b>(id) {
                <b>return</b> document.getElementById(id);
            },

            <i>/**
             * Clears the element cache
             * @deprecated Elements are not cached any longer
             * @method clearCache
             * @static
             * @private
             */</i>
            clearCache: <b>function</b>() { },

            <i>/**
             * hook up any deferred listeners
             * @method _load
             * @static
             * @private
             */</i>
            _load: <b>function</b>(e) {
                loadComplete = true;
                <b>var</b> EU = YAHOO.util.Event;
                <i>// Remove the listener to assist <b>with</b> the IE memory issue, but not</i>
                <i>// <b>for</b> other browsers because FF 1.0x does not like it.</i>
                <b>if</b> (<b>this</b>.isIE) {
                    EU._simpleRemove(window, &quot;load&quot;, EU._load);
                }
            },

            <i>/**
             * Polling <b>function</b> that runs before the onload event fires, 
             * attempting to attach to DOM Nodes as soon as they are 
             * available
             * @method _tryPreloadAttach
             * @static
             * @private
             */</i>
            _tryPreloadAttach: <b>function</b>() {

                <b>if</b> (<b>this</b>.locked) {
                    <b>return</b> false;
                }

                <b>this</b>.locked = true;

                <i>// keep trying until after the page is loaded.  We need to </i>
                <i>// check the page load state prior to trying to bind the </i>
                <i>// elements so that we can be certain all elements have been </i>
                <i>// tested appropriately</i>
                <b>var</b> tryAgain = !loadComplete;
                <b>if</b> (!tryAgain) {
                    tryAgain = (retryCount &gt; 0);
                }

                <i>// onAvailable</i>
                <b>var</b> notAvail = [];
                <b>for</b> (<b>var</b> i=0,len=onAvailStack.length; i&lt;len ; ++i) {
                    <b>var</b> item = onAvailStack[i];
                    <b>if</b> (item) {
                        <b>var</b> el = <b>this</b>.getEl(item.id);

                        <b>if</b> (el) {
                            <i>// The element is available, but not necessarily ready</i>

                            <b>if</b> ( !item.checkReady || 
                                    loadComplete || 
                                    el.nextSibling ||
                                    (document &amp;&amp; document.body) ) {

                                <b>var</b> scope = el;
                                <b>if</b> (item.override) {
                                    <b>if</b> (item.override === true) {
                                        scope = item.obj;
                                    } <b>else</b> {
                                        scope = item.override;
                                    }
                                }
                                item.fn.call(scope, item.obj);
                                <b>delete</b> onAvailStack[i];
                            }
                        } <b>else</b> {
                            notAvail.push(item);
                        }
                    }
                }

                retryCount = (notAvail.length === 0) ? 0 : retryCount - 1;

                <b>if</b> (tryAgain) {
                    <b>this</b>.startInterval();
                } <b>else</b> {
                    clearInterval(<b>this</b>._interval);
                    <b>this</b>._interval = null;
                }

                <b>this</b>.locked = false;

                <b>return</b> true;

            },

            <i>/**
             * Removes all listeners attached to the given element via addListener.
             * Optionally, the node's children can also be purged.
             * Optionally, you can specify a specific type of event to remove.
             * @method purgeElement
             * @param {HTMLElement} el the element to purge
             * @param {boolean} recurse recursively purge <b>this</b> element's children
             * as well.  Use <b>with</b> caution.
             * @param {string} sType optional type of listener to purge. If
             * left out, all listeners will be removed
             * @static
             */</i>
            purgeElement: <b>function</b>(el, recurse, sType) {
                <b>var</b> elListeners = <b>this</b>.getListeners(el, sType);
                <b>if</b> (elListeners) {
                    <b>for</b> (<b>var</b> i=0,len=elListeners.length; i&lt;len ; ++i) {
                        <b>var</b> l = elListeners[i];
                        <i>// can't use the index on the changing collection</i>
                        <i>//<b>this</b>.removeListener(el, l.type, l.fn, l.index);</i>
                        <b>this</b>.removeListener(el, l.type, l.fn);
                    }
                }

                <b>if</b> (recurse &amp;&amp; el &amp;&amp; el.childNodes) {
                    <b>for</b> (i=0,len=el.childNodes.length; i&lt;len ; ++i) {
                        <b>this</b>.purgeElement(el.childNodes[i], recurse, sType);
                    }
                }
            },

            <i>/**
             * Returns all listeners attached to the given element via addListener.
             * Optionally, you can specify a specific type of event to <b>return</b>.
             * @method getListeners
             * @param el {HTMLElement} the element to inspect 
             * @param sType {string} optional type of listener to <b>return</b>. If
             * left out, all listeners will be returned
             * @<b>return</b> {Object} the listener. Contains the following fields:
             * &amp;nbsp;&amp;nbsp;type:   (string)   the type of event
             * &amp;nbsp;&amp;nbsp;fn:     (<b>function</b>) the callback supplied to addListener
             * &amp;nbsp;&amp;nbsp;obj:    (object)   the custom object supplied to addListener
             * &amp;nbsp;&amp;nbsp;adjust: (boolean)  whether or not to adjust the <b>default</b> scope
             * &amp;nbsp;&amp;nbsp;index:  (int)      its position <b>in</b> the Event util listener cache
             * @static
             */</i>           
            getListeners: <b>function</b>(el, sType) {
                <b>var</b> elListeners = [];
                <b>if</b> (listeners &amp;&amp; listeners.length &gt; 0) {
                    <b>for</b> (<b>var</b> i=0,len=listeners.length; i&lt;len ; ++i) {
                        <b>var</b> l = listeners[i];
                        <b>if</b> ( l  &amp;&amp; l[<b>this</b>.EL] === el &amp;&amp; 
                                (!sType || sType === l[<b>this</b>.TYPE]) ) {
                            elListeners.push({
                                type:   l[<b>this</b>.TYPE],
                                fn:     l[<b>this</b>.FN],
                                obj:    l[<b>this</b>.OBJ],
                                adjust: l[<b>this</b>.ADJ_SCOPE],
                                index:  i
                            });
                        }
                    }
                }

                <b>return</b> (elListeners.length) ? elListeners : null;
            },

            <i>/**
             * Removes all listeners registered by pe.event.  Called 
             * automatically during the unload event.
             * @method _unload
             * @static
             * @private
             */</i>
            _unload: <b>function</b>(e) {

                <b>var</b> EU = YAHOO.util.Event, i, j, l, len, index;

                <b>for</b> (i=0,len=unloadListeners.length; i&lt;len; ++i) {
                    l = unloadListeners[i];
                    <b>if</b> (l) {
                        <b>var</b> scope = window;
                        <b>if</b> (l[EU.ADJ_SCOPE]) {
                            <b>if</b> (l[EU.ADJ_SCOPE] === true) {
                                scope = l[EU.OBJ];
                            } <b>else</b> {
                                scope = l[EU.ADJ_SCOPE];
                            }
                        }
                        l[EU.FN].call(scope, EU.getEvent(e), l[EU.OBJ] );
                        <b>delete</b> unloadListeners[i];
                        l=null;
                        scope=null;
                    }
                }

                <b>if</b> (listeners &amp;&amp; listeners.length &gt; 0) {
                    j = listeners.length;
                    <b>while</b> (j) {
                        index = j-1;
                        l = listeners[index];
                        <b>if</b> (l) {
                            EU.removeListener(l[EU.EL], l[EU.TYPE], 
                                    l[EU.FN], index);
                        } 
                        j = j - 1;
                    }
                    l=null;

                    EU.clearCache();
                }

                <b>for</b> (i=0,len=legacyEvents.length; i&lt;len; ++i) {
                    <i>// dereference the element</i>
                    <b>delete</b> legacyEvents[i][0];
                    <i>// <b>delete</b> the array item</i>
                    <b>delete</b> legacyEvents[i];
                }

                EU._simpleRemove(window, &quot;unload&quot;, EU._unload);

            },

            <i>/**
             * Returns scrollLeft
             * @method _getScrollLeft
             * @static
             * @private
             */</i>
            _getScrollLeft: <b>function</b>() {
                <b>return</b> this._getScroll()[1];
            },

            <i>/**
             * Returns scrollTop
             * @method _getScrollTop
             * @static
             * @private
             */</i>
            _getScrollTop: <b>function</b>() {
                <b>return</b> this._getScroll()[0];
            },

            <i>/**
             * Returns the scrollTop and scrollLeft.  Used to calculate the 
             * pageX and pageY <b>in</b> Internet Explorer
             * @method _getScroll
             * @static
             * @private
             */</i>
            _getScroll: <b>function</b>() {
                <b>var</b> dd = document.documentElement, db = document.body;
                <b>if</b> (dd &amp;&amp; (dd.scrollTop || dd.scrollLeft)) {
                    <b>return</b> [dd.scrollTop, dd.scrollLeft];
                } <b>else</b> if (db) {
                    <b>return</b> [db.scrollTop, db.scrollLeft];
                } <b>else</b> {
                    <b>return</b> [0, 0];
                }
            },

            <i>/**
             * Adds a DOM event directly without the caching, cleanup, scope adj, etc
             *
             * @method _simpleAdd
             * @param {HTMLElement} el      the element to bind the handler to
             * @param {string}      sType   the type of event handler
             * @param {<b>function</b>}    fn      the callback to invoke
             * @param {boolen}      capture capture or bubble phase
             * @static
             * @private
             */</i>
            _simpleAdd: <b>function</b> () {
                <b>if</b> (window.addEventListener) {
                    <b>return</b> function(el, sType, fn, capture) {
                        el.addEventListener(sType, fn, (capture));
                    };
                } <b>else</b> if (window.attachEvent) {
                    <b>return</b> function(el, sType, fn, capture) {
                        el.attachEvent(&quot;on&quot; + sType, fn);
                    };
                } <b>else</b> {
                    <b>return</b> function(){};
                }
            }(),

            <i>/**
             * Basic remove listener
             *
             * @method _simpleRemove
             * @param {HTMLElement} el      the element to bind the handler to
             * @param {string}      sType   the type of event handler
             * @param {<b>function</b>}    fn      the callback to invoke
             * @param {boolen}      capture capture or bubble phase
             * @static
             * @private
             */</i>
            _simpleRemove: <b>function</b>() {
                <b>if</b> (window.removeEventListener) {
                    <b>return</b> function (el, sType, fn, capture) {
                        el.removeEventListener(sType, fn, (capture));
                    };
                } <b>else</b> if (window.detachEvent) {
                    <b>return</b> function (el, sType, fn) {
                        el.detachEvent(&quot;on&quot; + sType, fn);
                    };
                } <b>else</b> {
                    <b>return</b> function(){};
                }
            }()
        };

    }();

    (<b>function</b>() {
        <b>var</b> EU = YAHOO.util.Event;

        <i>/**
         * YAHOO.util.Event.on is an alias <b>for</b> addListener
         * @method on
         * @see addListener
         * @static
         */</i>
        EU.on = EU.addListener;

        <i>// YAHOO.mix(EU, YAHOO.util.EventProvider.prototype);</i>
        <i>// EU.createEvent(&quot;DOMContentReady&quot;);</i>
        <i>// EU.subscribe(&quot;DOMContentReady&quot;, EU._load);</i>

        <b>if</b> (document &amp;&amp; document.body) {
            EU._load();
        } <b>else</b> {
            <i>// EU._simpleAdd(document, &quot;DOMContentLoaded&quot;, EU._load);</i>
            EU._simpleAdd(window, &quot;load&quot;, EU._load);
        }
        EU._simpleAdd(window, &quot;unload&quot;, EU._unload);
        EU._tryPreloadAttach();
    })();
}

<i>/**
 * EventProvider is designed to be used <b>with</b> YAHOO.augment to wrap 
 * CustomEvents <b>in</b> an interface that allows events to be subscribed to 
 * and fired by name.  This makes it possible <b>for</b> implementing code to
 * subscribe to an event that either has not been created yet, or will
 * not be created at all.
 *
 * @class EventProvider
 */</i>
YAHOO.util.EventProvider = <b>function</b>() { };

YAHOO.util.EventProvider.prototype = {

    <i>/**
     * Private storage of custom events
     * @property __yui_events
     * @type Object[]
     * @private
     */</i>
    __yui_events: null,

    <i>/**
     * Private storage of custom event subscribers
     * @property __yui_subscribers
     * @type Object[]
     * @private
     */</i>
    __yui_subscribers: null,
    
    <i>/**
     * Subscribe to a CustomEvent by event type
     *
     * @method subscribe
     * @param p_type     {string}   the type, or name of the event
     * @param p_fn       {<b>function</b>} the <b>function</b> to exectute when the event fires
     * @param p_obj
     * @param p_obj      {Object}   An object to be passed along when the event 
     *                              fires
     * @param p_override {boolean}  If true, the obj passed <b>in</b> becomes the 
     *                              execution scope of the listener
     */</i>
    subscribe: <b>function</b>(p_type, p_fn, p_obj, p_override) {

        <b>this</b>.__yui_events = <b>this</b>.__yui_events || {};
        <b>var</b> ce = <b>this</b>.__yui_events[p_type];

        <b>if</b> (ce) {
            ce.subscribe(p_fn, p_obj, p_override);
        } <b>else</b> {
            <b>this</b>.__yui_subscribers = <b>this</b>.__yui_subscribers || {};
            <b>var</b> subs = <b>this</b>.__yui_subscribers;
            <b>if</b> (!subs[p_type]) {
                subs[p_type] = [];
            }
            subs[p_type].push(
                { fn: p_fn, obj: p_obj, override: p_override } );
        }
    },

    <i>/**
     * Unsubscribes the from the specified event
     * @method unsubscribe
     * @param p_type {string}   The type, or name of the event
     * @param p_fn   {Function} The <b>function</b> to execute
     * @param p_obj  {Object}   The custom object passed to subscribe (optional)
     * @<b>return</b> {boolean} true <b>if</b> the subscriber was found and detached.
     */</i>
    unsubscribe: <b>function</b>(p_type, p_fn, p_obj) {
        <b>this</b>.__yui_events = <b>this</b>.__yui_events || {};
        <b>var</b> ce = <b>this</b>.__yui_events[p_type];
        <b>if</b> (ce) {
            <b>return</b> ce.unsubscribe(p_fn, p_obj);
        } <b>else</b> {
            <b>return</b> false;
        }
    },

    <i>/**
     * Creates a <b>new</b> custom event of the specified type.  If a custom event
     * by that name already exists, it will not be re-created.  In either
     * <b>case</b> the custom event is returned. 
     *
     * @method createEvent
     *
     * @param p_type {string} the type, or name of the event
     * @param p_config {object} optional config params.  Valid properties are:
     *
     *  &lt;ul&gt;
     *    &lt;li&gt;
     *      scope: defines the <b>default</b> execution scope.  If not defined
     *      the <b>default</b> scope will be <b>this</b> instance.
     *    &lt;/li&gt;
     *    &lt;li&gt;
     *      silent: <b>if</b> true, the custom event will not generate log messages.
     *      This is false by <b>default</b>.
     *    &lt;/li&gt;
     *    &lt;li&gt;
     *      onSubscribeCallback: specifies a callback to execute when the
     *      event has a <b>new</b> subscriber.  This will fire immediately <b>for</b>
     *      each queued subscriber <b>if</b> any exist prior to the creation of
     *      the event.
     *    &lt;/li&gt;
     *  &lt;/ul&gt;
     *
     *  @<b>return</b> {CustomEvent} the custom event
     *
     */</i>
    createEvent: <b>function</b>(p_type, p_config) {

        <b>this</b>.__yui_events = <b>this</b>.__yui_events || {};
        <b>var</b> opts = p_config || {};
        <b>var</b> events = <b>this</b>.__yui_events;

        <b>if</b> (events[p_type]) {
        } <b>else</b> {

            <b>var</b> scope  = opts.scope  || <b>this</b>;
            <b>var</b> silent = opts.silent || null;

            <b>var</b> ce = <b>new</b> YAHOO.util.CustomEvent(p_type, scope, silent,
                    YAHOO.util.CustomEvent.FLAT);
            events[p_type] = ce;

            <b>if</b> (opts.onSubscribeCallback) {
                ce.subscribeEvent.subscribe(opts.onSubscribeCallback);
            }

            <b>this</b>.__yui_subscribers = <b>this</b>.__yui_subscribers || {};
            <b>var</b> qs = <b>this</b>.__yui_subscribers[p_type];

            <b>if</b> (qs) {
                <b>for</b> (<b>var</b> i=0; i&lt;qs.length; ++i) {
                    ce.subscribe(qs[i].fn, qs[i].obj, qs[i].override);
                }
            }
        }

        <b>return</b> events[p_type];
    },

   <i>/**
     * Fire a custom event by name.  The callback functions will be executed
     * from the scope specified when the event was created, and <b>with</b> the 
     * following parameters:
     *   &lt;ul&gt;
     *   &lt;li&gt;The first argument fire() was executed <b>with</b>&lt;/li&gt;
     *   &lt;li&gt;The custom object (<b>if</b> any) that was passed into the subscribe() 
     *       method&lt;/li&gt;
     *   &lt;/ul&gt;
     * @method fireEvent
     * @param p_type    {string}  the type, or name of the event
     * @param arguments {Object*} an arbitrary set of parameters to pass to 
     *                            the handler.
     * @<b>return</b> {boolean} the <b>return</b> value from CustomEvent.fire, or null <b>if</b> 
     *                   the custom event does not exist.
     */</i>
    fireEvent: <b>function</b>(p_type, arg1, arg2, etc) {

        <b>this</b>.__yui_events = <b>this</b>.__yui_events || {};
        <b>var</b> ce = <b>this</b>.__yui_events[p_type];

        <b>if</b> (ce) {
            <b>var</b> args = [];
            <b>for</b> (<b>var</b> i=1; i&lt;arguments.length; ++i) {
                args.push(arguments[i]);
            }
            <b>return</b> ce.fire.apply(ce, args);
        } <b>else</b> {
            <b>return</b> null;
        }
    },

    <i>/**
     * Returns true <b>if</b> the custom event of the provided type has been created
     * <b>with</b> createEvent.
     * @method hasEvent
     * @param type {string} the type, or name of the event
     */</i>
    hasEvent: <b>function</b>(type) {
        <b>if</b> (<b>this</b>.__yui_events) {
            <b>if</b> (<b>this</b>.__yui_events[type]) {
                <b>return</b> true;
            }
        }
        <b>return</b> false;
    }

};

</code></pre><hr><div style="font-size:10px;text-align:center;color:gray;">yui-ext - Copyright &copy; 2006 Jack Slocum.  |
    Yahoo! UI - Copyright &copy; 2006 Yahoo! Inc.<br />All rights reserved.</div>
    </body></html>