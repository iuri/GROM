<html><head><title>calendar.js</title><link rel="stylesheet" type="text/css" href="../resources/style.css" media="screen"/></head><body><h1>calendar.js</h1><pre class="highlighted"><code><i>/*
Copyright (c) 2006, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http:<i>//developer.yahoo.net/yui/license.txt</i>
version 0.12.0
*/</i>
<i>// holder</i>
<i>/**
* Config is a utility used within an Object to allow the implementer to maintain a list of local configuration properties and listen <b>for</b> changes to those properties dynamically using CustomEvent. The initial values are also maintained so that the configuration can be reset at any given point to its initial state.
* @class YAHOO.util.Config
* @constructor
* @param {Object}	owner	The owner Object to which <b>this</b> Config Object belongs
*/</i>
YAHOO.util.Config = <b>function</b>(owner) {
	<b>if</b> (owner) {
		<b>this</b>.init(owner);
	}
};

YAHOO.util.Config.prototype = {

	<i>/**
	* Object reference to the owner of <b>this</b> Config Object
	* @property owner
	* @type Object
	*/</i>
	owner : null,

	<i>/**
	* Boolean flag that specifies whether a queue is currently being executed
	* @property queueInProgress
	* @type Boolean
	*/</i>
	queueInProgress : false,


	<i>/**
	* Validates that the value passed <b>in</b> is a Boolean.
	* @method checkBoolean
	* @param	{Object}	val	The value to validate
	* @<b>return</b>	{Boolean}	true, <b>if</b> the value is valid
	*/</i>
	checkBoolean: <b>function</b>(val) {
		<b>if</b> (<b>typeof</b> val == 'boolean') {
			<b>return</b> true;
		} <b>else</b> {
			<b>return</b> false;
		}
	},

	<i>/**
	* Validates that the value passed <b>in</b> is a number.
	* @method checkNumber
	* @param	{Object}	val	The value to validate
	* @<b>return</b>	{Boolean}	true, <b>if</b> the value is valid
	*/</i>
	checkNumber: <b>function</b>(val) {
		<b>if</b> (isNaN(val)) {
			<b>return</b> false;
		} <b>else</b> {
			<b>return</b> true;
		}
	}
};


<i>/**
* Initializes the configuration Object and all of its local members.
* @method init
* @param {Object}	owner	The owner Object to which <b>this</b> Config Object belongs
*/</i>
YAHOO.util.Config.prototype.init = <b>function</b>(owner) {

	<b>this</b>.owner = owner;

	<i>/**
	* Object reference to the owner of <b>this</b> Config Object
	* @event configChangedEvent
	*/</i>
	<b>this</b>.configChangedEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;configChanged&quot;);

	<b>this</b>.queueInProgress = false;

	<i>/* Private Members */</i>
<i>// holder</i>
<i>/**
	* Maintains the local collection of configuration property objects and their specified values
	* @property config
	* @private
	* @type Object
	*/</i>
	<b>var</b> config = {};

	<i>/**
	* Maintains the local collection of configuration property objects as they were initially applied.
	* This object is used when resetting a property.
	* @property initialConfig
	* @private
	* @type Object
	*/</i>
	<b>var</b> initialConfig = {};

	<i>/**
	* Maintains the local, normalized CustomEvent queue
	* @property eventQueue
	* @private
	* @type Object
	*/</i>
	<b>var</b> eventQueue = [];

	<i>/**
	* Fires a configuration property event using the specified value.
	* @method fireEvent
	* @private
	* @param {String}	key			The configuration property's name
	* @param {value}	Object		The value of the correct type <b>for</b> the property
	*/</i>
	<b>var</b> fireEvent = <b>function</b>( key, value ) {
		key = key.toLowerCase();

		<b>var</b> property = config[key];

		<b>if</b> (<b>typeof</b> property != 'undefined' &amp;&amp; property.event) {
			property.event.fire(value);
		}
	};
	<i>/* End Private Members */</i>
<i>// holder</i>
<i>/**
	* Adds a property to the Config Object's private config hash.
	* @method addProperty
	* @param {String}	key	The configuration property's name
	* @param {Object}	propertyObject	The Object containing all of <b>this</b> property's arguments
	*/</i>
	<b>this</b>.addProperty = <b>function</b>( key, propertyObject ) {
		key = key.toLowerCase();

		config[key] = propertyObject;

		propertyObject.event = <b>new</b> YAHOO.util.CustomEvent(key);
		propertyObject.key = key;

		<b>if</b> (propertyObject.handler) {
			propertyObject.event.subscribe(propertyObject.handler, <b>this</b>.owner, true);
		}

		<b>this</b>.setProperty(key, propertyObject.value, true);

		<b>if</b> (! propertyObject.suppressEvent) {
			<b>this</b>.queueProperty(key, propertyObject.value);
		}
	};

	<i>/**
	* Returns a key-value configuration map of the values currently set <b>in</b> the Config Object.
	* @method getConfig
	* @<b>return</b> {Object} The current config, represented <b>in</b> a key-value map
	*/</i>
	<b>this</b>.getConfig = <b>function</b>() {
		<b>var</b> cfg = {};

		<b>for</b> (<b>var</b> prop <b>in</b> config) {
			<b>var</b> property = config[prop];
			<b>if</b> (<b>typeof</b> property != 'undefined' &amp;&amp; property.event) {
				cfg[prop] = property.value;
			}
		}

		<b>return</b> cfg;
	};

	<i>/**
	* Returns the value of specified property.
	* @method getProperty
	* @param {String} key	The name of the property
	* @<b>return</b> {Object}		The value of the specified property
	*/</i>
	<b>this</b>.getProperty = <b>function</b>(key) {
		key = key.toLowerCase();

		<b>var</b> property = config[key];
		<b>if</b> (<b>typeof</b> property != 'undefined' &amp;&amp; property.event) {
			<b>return</b> property.value;
		} <b>else</b> {
			<b>return</b> undefined;
		}
	};

	<i>/**
	* Resets the specified property's value to its initial value.
	* @method resetProperty
	* @param {String} key	The name of the property
	* @<b>return</b> {Boolean} True is the property was reset, false <b>if</b> not
	*/</i>
	<b>this</b>.resetProperty = <b>function</b>(key) {
		key = key.toLowerCase();

		<b>var</b> property = config[key];
		<b>if</b> (<b>typeof</b> property != 'undefined' &amp;&amp; property.event) {
			<b>if</b> (initialConfig[key] &amp;&amp; initialConfig[key] != 'undefined')	{
				<b>this</b>.setProperty(key, initialConfig[key]);
			}
			<b>return</b> true;
		} <b>else</b> {
			<b>return</b> false;
		}
	};

	<i>/**
	* Sets the value of a property. If the silent property is passed as true, the property's event will not be fired.
	* @method setProperty
	* @param {String} key		The name of the property
	* @param {String} value		The value to set the property to
	* @param {Boolean} silent	Whether the value should be set silently, without firing the property event.
	* @<b>return</b> {Boolean}			True, <b>if</b> the set was successful, false <b>if</b> it failed.
	*/</i>
	<b>this</b>.setProperty = <b>function</b>(key, value, silent) {
		key = key.toLowerCase();

		<b>if</b> (<b>this</b>.queueInProgress &amp;&amp; ! silent) {
			<b>this</b>.queueProperty(key,value); <i>// Currently running through a queue...</i>
			<b>return</b> true;
		} <b>else</b> {
			<b>var</b> property = config[key];
			<b>if</b> (<b>typeof</b> property != 'undefined' &amp;&amp; property.event) {
				<b>if</b> (property.validator &amp;&amp; ! property.validator(value)) { <i>// validator</i>
					<b>return</b> false;
				} <b>else</b> {
					property.value = value;
					<b>if</b> (! silent) {
						fireEvent(key, value);
						<b>this</b>.configChangedEvent.fire([key, value]);
					}
					<b>return</b> true;
				}
			} <b>else</b> {
				<b>return</b> false;
			}
		}
	};

	<i>/**
	* Sets the value of a property and queues its event to execute. If the event is already scheduled to execute, it is
	* moved from its current position to the end of the queue.
	* @method queueProperty
	* @param {String} key	The name of the property
	* @param {String} value	The value to set the property to
	* @<b>return</b> {Boolean}		true, <b>if</b> the set was successful, false <b>if</b> it failed.
	*/</i>
	<b>this</b>.queueProperty = <b>function</b>(key, value) {
		key = key.toLowerCase();

		<b>var</b> property = config[key];

		<b>if</b> (<b>typeof</b> property != 'undefined' &amp;&amp; property.event) {
			<b>if</b> (<b>typeof</b> value != 'undefined' &amp;&amp; property.validator &amp;&amp; ! property.validator(value)) { <i>// validator</i>
				<b>return</b> false;
			} <b>else</b> {

				<b>if</b> (<b>typeof</b> value != 'undefined') {
					property.value = value;
				} <b>else</b> {
					value = property.value;
				}

				<b>var</b> foundDuplicate = false;

				<b>for</b> (<b>var</b> i=0;i&lt;eventQueue.length;i++) {
					<b>var</b> queueItem = eventQueue[i];

					<b>if</b> (queueItem) {
						<b>var</b> queueItemKey = queueItem[0];
						<b>var</b> queueItemValue = queueItem[1];

						<b>if</b> (queueItemKey.toLowerCase() == key) {
							<i>// found a dupe... push to end of queue, null current item, and <b>break</b></i>
							eventQueue[i] = null;
							eventQueue.push([key, (<b>typeof</b> value != 'undefined' ? value : queueItemValue)]);
							foundDuplicate = true;
							<b>break</b>;
						}
					}
				}

				<b>if</b> (! foundDuplicate &amp;&amp; <b>typeof</b> value != 'undefined') { <i>// <b>this</b> is a refire, or a <b>new</b> property <b>in</b> the queue</i>
					eventQueue.push([key, value]);
				}
			}

			<b>if</b> (property.supercedes) {
				<b>for</b> (<b>var</b> s=0;s&lt;property.supercedes.length;s++) {
					<b>var</b> supercedesCheck = property.supercedes[s];

					<b>for</b> (<b>var</b> q=0;q&lt;eventQueue.length;q++) {
						<b>var</b> queueItemCheck = eventQueue[q];

						<b>if</b> (queueItemCheck) {
							<b>var</b> queueItemCheckKey = queueItemCheck[0];
							<b>var</b> queueItemCheckValue = queueItemCheck[1];

							<b>if</b> ( queueItemCheckKey.toLowerCase() == supercedesCheck.toLowerCase() ) {
								eventQueue.push([queueItemCheckKey, queueItemCheckValue]);
								eventQueue[q] = null;
								<b>break</b>;
							}
						}
					}
				}
			}

			<b>return</b> true;
		} <b>else</b> {
			<b>return</b> false;
		}
	};

	<i>/**
	* Fires the event <b>for</b> a property using the property's current value.
	* @method refireEvent
	* @param {String} key	The name of the property
	*/</i>
	<b>this</b>.refireEvent = <b>function</b>(key) {
		key = key.toLowerCase();

		<b>var</b> property = config[key];
		<b>if</b> (<b>typeof</b> property != 'undefined' &amp;&amp; property.event &amp;&amp; <b>typeof</b> property.value != 'undefined') {
			<b>if</b> (<b>this</b>.queueInProgress) {
				<b>this</b>.queueProperty(key);
			} <b>else</b> {
				fireEvent(key, property.value);
			}
		}
	};

	<i>/**
	* Applies a key-value Object literal to the configuration, replacing any existing values, and queueing the property events.
	* Although the values will be set, fireQueue() must be called <b>for</b> their associated events to execute.
	* @method applyConfig
	* @param {Object}	userConfig	The configuration Object literal
	* @param {Boolean}	init		When set to true, the initialConfig will be set to the userConfig passed <b>in</b>, so that calling a reset will reset the properties to the passed values.
	*/</i>
	<b>this</b>.applyConfig = <b>function</b>(userConfig, init) {
		<b>if</b> (init) {
			initialConfig = userConfig;
		}
		<b>for</b> (<b>var</b> prop <b>in</b> userConfig) {
			<b>this</b>.queueProperty(prop, userConfig[prop]);
		}
	};

	<i>/**
	* Refires the events <b>for</b> all configuration properties using their current values.
	* @method refresh
	*/</i>
	<b>this</b>.refresh = <b>function</b>() {
		<b>for</b> (<b>var</b> prop <b>in</b> config) {
			<b>this</b>.refireEvent(prop);
		}
	};

	<i>/**
	* Fires the normalized list of queued property change events
	* @method fireQueue
	*/</i>
	<b>this</b>.fireQueue = <b>function</b>() {
		<b>this</b>.queueInProgress = true;
		<b>for</b> (<b>var</b> i=0;i&lt;eventQueue.length;i++) {
			<b>var</b> queueItem = eventQueue[i];
			<b>if</b> (queueItem) {
				<b>var</b> key = queueItem[0];
				<b>var</b> value = queueItem[1];

				<b>var</b> property = config[key];
				property.value = value;

				fireEvent(key,value);
			}
		}

		<b>this</b>.queueInProgress = false;
		eventQueue = [];
	};

	<i>/**
	* Subscribes an external handler to the change event <b>for</b> any given property.
	* @method subscribeToConfigEvent
	* @param {String}	key			The property name
	* @param {Function}	handler		The handler <b>function</b> to use subscribe to the property's event
	* @param {Object}	obj			The Object to use <b>for</b> scoping the event handler (see CustomEvent documentation)
	* @param {Boolean}	override	Optional. If true, will override &quot;<b>this</b>&quot; within the handler to map to the scope Object passed into the method.
	* @<b>return</b> {Boolean}				True, <b>if</b> the subscription was successful, otherwise false.
	*/</i>
	<b>this</b>.subscribeToConfigEvent = <b>function</b>(key, handler, obj, override) {
		key = key.toLowerCase();

		<b>var</b> property = config[key];
		<b>if</b> (<b>typeof</b> property != 'undefined' &amp;&amp; property.event) {
			<b>if</b> (! YAHOO.util.Config.alreadySubscribed(property.event, handler, obj)) {
				property.event.subscribe(handler, obj, override);
			}
			<b>return</b> true;
		} <b>else</b> {
			<b>return</b> false;
		}
	};

	<i>/**
	* Unsubscribes an external handler from the change event <b>for</b> any given property.
	* @method unsubscribeFromConfigEvent
	* @param {String}	key			The property name
	* @param {Function}	handler		The handler <b>function</b> to use subscribe to the property's event
	* @param {Object}	obj			The Object to use <b>for</b> scoping the event handler (see CustomEvent documentation)
	* @<b>return</b> {Boolean}				True, <b>if</b> the unsubscription was successful, otherwise false.
	*/</i>
	<b>this</b>.unsubscribeFromConfigEvent = <b>function</b>(key, handler, obj) {
		key = key.toLowerCase();

		<b>var</b> property = config[key];
		<b>if</b> (<b>typeof</b> property != 'undefined' &amp;&amp; property.event) {
			<b>return</b> property.event.unsubscribe(handler, obj);
		} <b>else</b> {
			<b>return</b> false;
		}
	};

	<i>/**
	* Returns a string representation of the Config object
	* @method toString
	* @<b>return</b> {String}	The Config object <b>in</b> string format.
	*/</i>
	<b>this</b>.toString = <b>function</b>() {
		<b>var</b> output = &quot;Config&quot;;
		<b>if</b> (<b>this</b>.owner) {
			output += &quot; [&quot; + <b>this</b>.owner.toString() + &quot;]&quot;;
		}
		<b>return</b> output;
	};

	<i>/**
	* Returns a string representation of the Config object's current CustomEvent queue
	* @method outputEventQueue
	* @<b>return</b> {String}	The string list of CustomEvents currently queued <b>for</b> execution
	*/</i>
	<b>this</b>.outputEventQueue = <b>function</b>() {
		<b>var</b> output = &quot;&quot;;
		<b>for</b> (<b>var</b> q=0;q&lt;eventQueue.length;q++) {
			<b>var</b> queueItem = eventQueue[q];
			<b>if</b> (queueItem) {
				output += queueItem[0] + &quot;=&quot; + queueItem[1] + &quot;, &quot;;
			}
		}
		<b>return</b> output;
	};
};

<i>/**
* Checks to determine <b>if</b> a particular <b>function</b>/Object pair are already subscribed to the specified CustomEvent
* @method YAHOO.util.Config.alreadySubscribed
* @static
* @param {YAHOO.util.CustomEvent} evt	The CustomEvent <b>for</b> which to check the subscriptions
* @param {Function}	fn	The <b>function</b> to look <b>for</b> in the subscribers list
* @param {Object}	obj	The execution scope Object <b>for</b> the subscription
* @<b>return</b> {Boolean}	true, <b>if</b> the <b>function</b>/Object pair is already subscribed to the CustomEvent passed <b>in</b>
*/</i>
YAHOO.util.Config.alreadySubscribed = <b>function</b>(evt, fn, obj) {
	<b>for</b> (<b>var</b> e=0;e&lt;evt.subscribers.length;e++) {
		<b>var</b> subsc = evt.subscribers[e];
		<b>if</b> (subsc &amp;&amp; subsc.obj == obj &amp;&amp; subsc.fn == fn) {
			<b>return</b> true;
		}
	}
	<b>return</b> false;
};

<i>/**
* YAHOO.widget.DateMath is used <b>for</b> simple date manipulation. The class is a static utility
* used <b>for</b> adding, subtracting, and comparing dates.
* @class YAHOO.widget.DateMath
*/</i>
YAHOO.widget.DateMath = {
	<i>/**
	* Constant field representing Day
	* @property DAY
	* @static
	* @final
	* @type String
	*/</i>
	DAY : &quot;D&quot;,

	<i>/**
	* Constant field representing Week
	* @property WEEK
	* @static
	* @final
	* @type String
	*/</i>
	WEEK : &quot;W&quot;,

	<i>/**
	* Constant field representing Year
	* @property YEAR
	* @static
	* @final
	* @type String
	*/</i>
	YEAR : &quot;Y&quot;,

	<i>/**
	* Constant field representing Month
	* @property MONTH
	* @static
	* @final
	* @type String
	*/</i>
	MONTH : &quot;M&quot;,

	<i>/**
	* Constant field representing one day, <b>in</b> milliseconds
	* @property ONE_DAY_MS
	* @static
	* @final
	* @type Number
	*/</i>
	ONE_DAY_MS : 1000*60*60*24,

	<i>/**
	* Adds the specified amount of time to the <b>this</b> instance.
	* @method add
	* @param {Date} date	The JavaScript Date object to perform addition on
	* @param {String} field	The field constant to be used <b>for</b> performing addition.
	* @param {Number} amount	The number of units (measured <b>in</b> the field constant) to add to the date.
	* @<b>return</b> {Date} The resulting Date object
	*/</i>
	add : <b>function</b>(date, field, amount) {
		<b>var</b> d = <b>new</b> Date(date.getTime());
		<b>switch</b> (field) {
			<b>case</b> this.MONTH:
				<b>var</b> newMonth = date.getMonth() + amount;
				<b>var</b> years = 0;


				<b>if</b> (newMonth &lt; 0) {
					<b>while</b> (newMonth &lt; 0) {
						newMonth += 12;
						years -= 1;
					}
				} <b>else</b> if (newMonth &gt; 11) {
					<b>while</b> (newMonth &gt; 11) {
						newMonth -= 12;
						years += 1;
					}
				}

				d.setMonth(newMonth);
				d.setFullYear(date.getFullYear() + years);
				<b>break</b>;
			<b>case</b> this.DAY:
				d.setDate(date.getDate() + amount);
				<b>break</b>;
			<b>case</b> this.YEAR:
				d.setFullYear(date.getFullYear() + amount);
				<b>break</b>;
			<b>case</b> this.WEEK:
				d.setDate(date.getDate() + (amount * 7));
				<b>break</b>;
		}
		<b>return</b> d;
	},

	<i>/**
	* Subtracts the specified amount of time from the <b>this</b> instance.
	* @method subtract
	* @param {Date} date	The JavaScript Date object to perform subtraction on
	* @param {Number} field	The <b>this</b> field constant to be used <b>for</b> performing subtraction.
	* @param {Number} amount	The number of units (measured <b>in</b> the field constant) to subtract from the date.
	* @<b>return</b> {Date} The resulting Date object
	*/</i>
	subtract : <b>function</b>(date, field, amount) {
		<b>return</b> this.add(date, field, (amount*-1));
	},

	<i>/**
	* Determines whether a given date is before another date on the calendar.
	* @method before
	* @param {Date} date		The Date object to compare <b>with</b> the compare argument
	* @param {Date} compareTo	The Date object to use <b>for</b> the comparison
	* @<b>return</b> {Boolean} true <b>if</b> the date occurs before the compared date; false <b>if</b> not.
	*/</i>
	before : <b>function</b>(date, compareTo) {
		<b>var</b> ms = compareTo.getTime();
		<b>if</b> (date.getTime() &lt; ms) {
			<b>return</b> true;
		} <b>else</b> {
			<b>return</b> false;
		}
	},

	<i>/**
	* Determines whether a given date is after another date on the calendar.
	* @method after
	* @param {Date} date		The Date object to compare <b>with</b> the compare argument
	* @param {Date} compareTo	The Date object to use <b>for</b> the comparison
	* @<b>return</b> {Boolean} true <b>if</b> the date occurs after the compared date; false <b>if</b> not.
	*/</i>
	after : <b>function</b>(date, compareTo) {
		<b>var</b> ms = compareTo.getTime();
		<b>if</b> (date.getTime() &gt; ms) {
			<b>return</b> true;
		} <b>else</b> {
			<b>return</b> false;
		}
	},

	<i>/**
	* Determines whether a given date is between two other dates on the calendar.
	* @method between
	* @param {Date} date		The date to check <b>for</b>
	* @param {Date} dateBegin	The start of the range
	* @param {Date} dateEnd		The end of the range
	* @<b>return</b> {Boolean} true <b>if</b> the date occurs between the compared dates; false <b>if</b> not.
	*/</i>
	between : <b>function</b>(date, dateBegin, dateEnd) {
		<b>if</b> (<b>this</b>.after(date, dateBegin) &amp;&amp; <b>this</b>.before(date, dateEnd)) {
			<b>return</b> true;
		} <b>else</b> {
			<b>return</b> false;
		}
	},

	<i>/**
	* Retrieves a JavaScript Date object representing January 1 of any given year.
	* @method getJan1
	* @param {Number} calendarYear		The calendar year <b>for</b> which to retrieve January 1
	* @<b>return</b> {Date}	January 1 of the calendar year specified.
	*/</i>
	getJan1 : <b>function</b>(calendarYear) {
		<b>return</b> new Date(calendarYear,0,1);
	},

	<i>/**
	* Calculates the number of days the specified date is from January 1 of the specified calendar year.
	* Passing January 1 to <b>this</b> function would <b>return</b> an offset value of zero.
	* @method getDayOffset
	* @param {Date}	date	The JavaScript date <b>for</b> which to find the offset
	* @param {Number} calendarYear	The calendar year to use <b>for</b> determining the offset
	* @<b>return</b> {Number}	The number of days since January 1 of the given year
	*/</i>
	getDayOffset : <b>function</b>(date, calendarYear) {
		<b>var</b> beginYear = <b>this</b>.getJan1(calendarYear); <i>// Find the start of the year. This will be <b>in</b> week 1.</i>

		<i>// Find the number of days the passed <b>in</b> date is away from the calendar year start</i>
		<b>var</b> dayOffset = Math.ceil((date.getTime()-beginYear.getTime()) / <b>this</b>.ONE_DAY_MS);
		<b>return</b> dayOffset;
	},

	<i>/**
	* Calculates the week number <b>for</b> the given date. This <b>function</b> assumes that week 1 is the
	* week <b>in</b> which January 1 appears, regardless of whether the week consists of a full 7 days.
	* The calendar year can be specified to help find what a the week number would be <b>for</b> a given
	* date <b>if</b> the date overlaps years. For instance, a week may be considered week 1 of 2005, or
	* week 53 of 2004. Specifying the optional calendarYear allows one to make <b>this</b> distinction
	* easily.
	* @method getWeekNumber
	* @param {Date}	date	The JavaScript date <b>for</b> which to find the week number
	* @param {Number} calendarYear	OPTIONAL - The calendar year to use <b>for</b> determining the week number. Default is
	*											the calendar year of parameter &quot;date&quot;.
	* @param {Number} weekStartsOn	OPTIONAL - The integer (0-6) representing which day a week begins on. Default is 0 (<b>for</b> Sunday).
	* @<b>return</b> {Number}	The week number of the given date.
	*/</i>
	getWeekNumber : <b>function</b>(date, calendarYear) {
		date = <b>this</b>.clearTime(date);
		<b>var</b> nearestThurs = <b>new</b> Date(date.getTime() + (4 * <b>this</b>.ONE_DAY_MS) - ((date.getDay()) * <b>this</b>.ONE_DAY_MS));

		<b>var</b> jan1 = <b>new</b> Date(nearestThurs.getFullYear(),0,1);
		<b>var</b> dayOfYear = ((nearestThurs.getTime() - jan1.getTime()) / <b>this</b>.ONE_DAY_MS) - 1;

		<b>var</b> weekNum = Math.ceil((dayOfYear)/ 7);
		<b>return</b> weekNum;
	},

	<i>/**
	* Determines <b>if</b> a given week overlaps two different years.
	* @method isYearOverlapWeek
	* @param {Date}	weekBeginDate	The JavaScript Date representing the first day of the week.
	* @<b>return</b> {Boolean}	true <b>if</b> the date overlaps two different years.
	*/</i>
	isYearOverlapWeek : <b>function</b>(weekBeginDate) {
		<b>var</b> overlaps = false;
		<b>var</b> nextWeek = <b>this</b>.add(weekBeginDate, <b>this</b>.DAY, 6);
		<b>if</b> (nextWeek.getFullYear() != weekBeginDate.getFullYear()) {
			overlaps = true;
		}
		<b>return</b> overlaps;
	},

	<i>/**
	* Determines <b>if</b> a given week overlaps two different months.
	* @method isMonthOverlapWeek
	* @param {Date}	weekBeginDate	The JavaScript Date representing the first day of the week.
	* @<b>return</b> {Boolean}	true <b>if</b> the date overlaps two different months.
	*/</i>
	isMonthOverlapWeek : <b>function</b>(weekBeginDate) {
		<b>var</b> overlaps = false;
		<b>var</b> nextWeek = <b>this</b>.add(weekBeginDate, <b>this</b>.DAY, 6);
		<b>if</b> (nextWeek.getMonth() != weekBeginDate.getMonth()) {
			overlaps = true;
		}
		<b>return</b> overlaps;
	},

	<i>/**
	* Gets the first day of a month containing a given date.
	* @method findMonthStart
	* @param {Date}	date	The JavaScript Date used to calculate the month start
	* @<b>return</b> {Date}		The JavaScript Date representing the first day of the month
	*/</i>
	findMonthStart : <b>function</b>(date) {
		<b>var</b> start = <b>new</b> Date(date.getFullYear(), date.getMonth(), 1);
		<b>return</b> start;
	},

	<i>/**
	* Gets the last day of a month containing a given date.
	* @method findMonthEnd
	* @param {Date}	date	The JavaScript Date used to calculate the month end
	* @<b>return</b> {Date}		The JavaScript Date representing the last day of the month
	*/</i>
	findMonthEnd : <b>function</b>(date) {
		<b>var</b> start = <b>this</b>.findMonthStart(date);
		<b>var</b> nextMonth = <b>this</b>.add(start, <b>this</b>.MONTH, 1);
		<b>var</b> end = <b>this</b>.subtract(nextMonth, <b>this</b>.DAY, 1);
		<b>return</b> end;
	},

	<i>/**
	* Clears the time fields from a given date, effectively setting the time to midnight.
	* @method clearTime
	* @param {Date}	date	The JavaScript Date <b>for</b> which the time fields will be cleared
	* @<b>return</b> {Date}		The JavaScript Date cleared of all time fields
	*/</i>
	clearTime : <b>function</b>(date) {
		date.setHours(12,0,0,0);
		<b>return</b> date;
	}
};

<i>/**
* The Calendar component is a UI control that enables users to choose one or more dates from a graphical calendar presented <b>in</b> a one-month (&quot;one-up&quot;) or two-month (&quot;two-up&quot;) interface. Calendars are generated entirely via script and can be navigated without any page refreshes.
* @module    Calendar
* @title     Calendar Widget
* @namespace YAHOO.widget
* @requires  yahoo,dom,event
*/</i>
<i>// holder</i>
<i>/**
* Calendar is the base class <b>for</b> the Calendar widget. In its most basic
* implementation, it has the ability to render a calendar widget on the page
* that can be manipulated to select a single date, move back and forth between
* months and years.
* &lt;p&gt;To construct the placeholder <b>for</b> the calendar widget, the code is as
* follows:
*	&lt;xmp&gt;
*		&lt;div id=&quot;cal1Container&quot;&gt;&lt;/div&gt;
*	&lt;/xmp&gt;
* Note that the table can be replaced <b>with</b> any kind of element.
* &lt;/p&gt;
* @namespace YAHOO.widget
* @class Calendar
* @constructor
* @param {String}	id			The id of the table element that will represent the calendar widget
* @param {String}	containerId	The id of the container div element that will wrap the calendar table
* @param {Object}	config		The configuration object containing the Calendar's arguments
*/</i>
YAHOO.widget.Calendar = <b>function</b>(id, containerId, config) {
	<b>this</b>.init(id, containerId, config);
};

<i>/**
* The path to be used <b>for</b> images loaded <b>for</b> the Calendar
* @property YAHOO.widget.Calendar.IMG_ROOT
* @static
* @type String
*/</i>
YAHOO.widget.Calendar.IMG_ROOT = (window.location.href.toLowerCase().indexOf(&quot;https&quot;) === 0 ? &quot;https:<i>//a248.e.akamai.net/sec.yimg.com/i/&quot; : &quot;http://us.i1.yimg.com/us.yimg.com/i/&quot;);</i>

<i>/**
* Type constant used <b>for</b> renderers to represent an individual date (M/D/Y)
* @property YAHOO.widget.Calendar.DATE
* @static
* @final
* @type String
*/</i>
YAHOO.widget.Calendar.DATE = &quot;D&quot;;

<i>/**
* Type constant used <b>for</b> renderers to represent an individual date across any year (M/D)
* @property YAHOO.widget.Calendar.MONTH_DAY
* @static
* @final
* @type String
*/</i>
YAHOO.widget.Calendar.MONTH_DAY = &quot;MD&quot;;

<i>/**
* Type constant used <b>for</b> renderers to represent a weekday
* @property YAHOO.widget.Calendar.WEEKDAY
* @static
* @final
* @type String
*/</i>
YAHOO.widget.Calendar.WEEKDAY = &quot;WD&quot;;

<i>/**
* Type constant used <b>for</b> renderers to represent a range of individual dates (M/D/Y-M/D/Y)
* @property YAHOO.widget.Calendar.RANGE
* @static
* @final
* @type String
*/</i>
YAHOO.widget.Calendar.RANGE = &quot;R&quot;;

<i>/**
* Type constant used <b>for</b> renderers to represent a month across any year
* @property YAHOO.widget.Calendar.MONTH
* @static
* @final
* @type String
*/</i>
YAHOO.widget.Calendar.MONTH = &quot;M&quot;;

<i>/**
* Constant that represents the total number of date cells that are displayed <b>in</b> a given month
* @property YAHOO.widget.Calendar.DISPLAY_DAYS
* @static
* @final
* @type Number
*/</i>
YAHOO.widget.Calendar.DISPLAY_DAYS = 42;

<i>/**
* Constant used <b>for</b> halting the execution of the remainder of the render stack
* @property YAHOO.widget.Calendar.STOP_RENDER
* @static
* @final
* @type String
*/</i>
YAHOO.widget.Calendar.STOP_RENDER = &quot;S&quot;;

YAHOO.widget.Calendar.prototype = {

	<i>/**
	* The configuration object used to set up the calendars various locale and style options.
	* @property Config
	* @private
	* @deprecated Configuration properties should be set by calling Calendar.cfg.setProperty.
	* @type Object
	*/</i>
	Config : null,

	<i>/**
	* The parent CalendarGroup, only to be set explicitly by the parent group
	* @property parent
	* @type CalendarGroup
	*/</i>
	parent : null,

	<i>/**
	* The index of <b>this</b> item <b>in</b> the parent group
	* @property index
	* @type Number
	*/</i>
	index : -1,

	<i>/**
	* The collection of calendar table cells
	* @property cells
	* @type HTMLTableCellElement[]
	*/</i>
	cells : null,

	<i>/**
	* The collection of calendar cell dates that is parallel to the cells collection. The array contains dates field arrays <b>in</b> the format of [YYYY, M, D].
	* @property cellDates
	* @type Array[](Number[])
	*/</i>
	cellDates : null,

	<i>/**
	* The id that uniquely identifies <b>this</b> calendar. This id should match the id of the placeholder element on the page.
	* @property id
	* @type String
	*/</i>
	id : null,

	<i>/**
	* The DOM element reference that points to <b>this</b> calendar's container element. The calendar will be inserted into <b>this</b> element when the shell is rendered.
	* @property oDomContainer
	* @type HTMLElement
	*/</i>
	oDomContainer : null,

	<i>/**
	* A Date object representing today's date.
	* @property today
	* @type Date
	*/</i>
	today : null,

	<i>/**
	* The list of render functions, along <b>with</b> required parameters, used to render cells.
	* @property renderStack
	* @type Array[]
	*/</i>
	renderStack : null,

	<i>/**
	* A copy of the initial render functions created before rendering.
	* @property _renderStack
	* @private
	* @type Array
	*/</i>
	_renderStack : null,

	<i>/**
	* A Date object representing the month/year that the calendar is initially set to
	* @property _pageDate
	* @private
	* @type Date
	*/</i>
	_pageDate : null,

	<i>/**
	* The private list of initially selected dates.
	* @property _selectedDates
	* @private
	* @type Array
	*/</i>
	_selectedDates : null,

	<i>/**
	* A map of DOM event handlers to attach to cells associated <b>with</b> specific CSS class names
	* @property domEventMap
	* @type Object
	*/</i>
	domEventMap : null
};



<i>/**
* Initializes the Calendar widget.
* @method init
* @param {String}	id			The id of the table element that will represent the calendar widget
* @param {String}	containerId	The id of the container div element that will wrap the calendar table
* @param {Object}	config		The configuration object containing the Calendar's arguments
*/</i>
YAHOO.widget.Calendar.prototype.init = <b>function</b>(id, containerId, config) {
	<b>this</b>.initEvents();
	<b>this</b>.today = <b>new</b> Date();
	YAHOO.widget.DateMath.clearTime(<b>this</b>.today);

	<b>this</b>.id = id;
	<b>this</b>.oDomContainer = document.getElementById(containerId);

	<i>/**
	* The Config object used to hold the configuration variables <b>for</b> the Calendar
	* @property cfg
	* @type YAHOO.util.Config
	*/</i>
	<b>this</b>.cfg = <b>new</b> YAHOO.util.Config(<b>this</b>);

	<i>/**
	* The local object which contains the Calendar's options
	* @property Options
	* @type Object
	*/</i>
	<b>this</b>.Options = {};

	<i>/**
	* The local object which contains the Calendar's locale settings
	* @property Locale
	* @type Object
	*/</i>
	<b>this</b>.Locale = {};

	<b>this</b>.initStyles();

	YAHOO.util.Dom.addClass(<b>this</b>.oDomContainer, <b>this</b>.Style.CSS_CONTAINER);
	YAHOO.util.Dom.addClass(<b>this</b>.oDomContainer, <b>this</b>.Style.CSS_SINGLE);

	<b>this</b>.cellDates = [];
	<b>this</b>.cells = [];
	<b>this</b>.renderStack = [];
	<b>this</b>._renderStack = [];

	<b>this</b>.setupConfig();

	<b>if</b> (config) {
		<b>this</b>.cfg.applyConfig(config, true);
	}

	<b>this</b>.cfg.fireQueue();
};

<i>/**
* Renders the built-<b>in</b> IFRAME shim <b>for</b> the IE6 and below
* @method configIframe
*/</i>
YAHOO.widget.Calendar.prototype.configIframe = <b>function</b>(type, args, obj) {
	<b>var</b> useIframe = args[0];

	<b>if</b> (YAHOO.util.Dom.inDocument(<b>this</b>.oDomContainer)) {
		<b>if</b> (useIframe) {
			<b>var</b> pos = YAHOO.util.Dom.getStyle(<b>this</b>.oDomContainer, &quot;position&quot;);

			<b>if</b> (<b>this</b>.browser == &quot;ie&quot; &amp;&amp; (pos == &quot;absolute&quot; || pos == &quot;relative&quot;)) {
				<b>if</b> (! YAHOO.util.Dom.inDocument(<b>this</b>.iframe)) {
					<b>this</b>.iframe = document.createElement(&quot;iframe&quot;);
					<b>this</b>.iframe.src = &quot;javascript:false;&quot;;
					YAHOO.util.Dom.setStyle(<b>this</b>.iframe, &quot;opacity&quot;, &quot;0&quot;);
					<b>this</b>.oDomContainer.insertBefore(<b>this</b>.iframe, <b>this</b>.oDomContainer.firstChild);
				}
			}
		} <b>else</b> {
			<b>if</b> (<b>this</b>.iframe) {
				<b>if</b> (<b>this</b>.iframe.parentNode) {
					<b>this</b>.iframe.parentNode.removeChild(<b>this</b>.iframe);
				}
				<b>this</b>.iframe = null;
			}
		}
	}
};

<i>/**
* Default handler <b>for</b> the &quot;title&quot; property
* @method configTitle
*/</i>
YAHOO.widget.Calendar.prototype.configTitle = <b>function</b>(type, args, obj) {
	<b>var</b> title = args[0];
	<b>var</b> close = <b>this</b>.cfg.getProperty(&quot;close&quot;);

	<b>var</b> titleDiv;

	<b>if</b> (title &amp;&amp; title !== &quot;&quot;) {
		titleDiv = YAHOO.util.Dom.getElementsByClassName(YAHOO.widget.CalendarGroup.CSS_2UPTITLE, &quot;div&quot;, <b>this</b>.oDomContainer)[0] || document.createElement(&quot;div&quot;);
		titleDiv.className = YAHOO.widget.CalendarGroup.CSS_2UPTITLE;
		titleDiv.innerHTML = title;
		<b>this</b>.oDomContainer.insertBefore(titleDiv, <b>this</b>.oDomContainer.firstChild);
		YAHOO.util.Dom.addClass(<b>this</b>.oDomContainer, &quot;withtitle&quot;);
	} <b>else</b> {
		titleDiv = YAHOO.util.Dom.getElementsByClassName(YAHOO.widget.CalendarGroup.CSS_2UPTITLE, &quot;div&quot;, <b>this</b>.oDomContainer)[0] || null;

		<b>if</b> (titleDiv) {
			YAHOO.util.Event.purgeElement(titleDiv);
			<b>this</b>.oDomContainer.removeChild(titleDiv);
		}
		<b>if</b> (! close) {
			YAHOO.util.Dom.removeClass(<b>this</b>.oDomContainer, &quot;withtitle&quot;);
		}
	}
};

<i>/**
* Default handler <b>for</b> the &quot;close&quot; property
* @method configClose
*/</i>
YAHOO.widget.Calendar.prototype.configClose = <b>function</b>(type, args, obj) {
	<b>var</b> close = args[0];
	<b>var</b> title = <b>this</b>.cfg.getProperty(&quot;title&quot;);

	<b>var</b> linkClose;

	<b>if</b> (close === true) {
		linkClose = YAHOO.util.Dom.getElementsByClassName(&quot;link-close&quot;, &quot;a&quot;, <b>this</b>.oDomContainer)[0] || document.createElement(&quot;a&quot;);
		linkClose.href = &quot;javascript:<b>void</b>(null);&quot;;
		linkClose.className = &quot;link-close&quot;;
		YAHOO.util.Event.addListener(linkClose, &quot;click&quot;, <b>this</b>.hide, <b>this</b>, true);
		<b>var</b> imgClose = document.createElement(&quot;img&quot;);
		imgClose.src = YAHOO.widget.Calendar.IMG_ROOT + &quot;us/my/bn/x_d.gif&quot;;
		imgClose.className = YAHOO.widget.CalendarGroup.CSS_2UPCLOSE;
		linkClose.appendChild(imgClose);
		<b>this</b>.oDomContainer.appendChild(linkClose);
		YAHOO.util.Dom.addClass(<b>this</b>.oDomContainer, &quot;withtitle&quot;);
	} <b>else</b> {
		linkClose = YAHOO.util.Dom.getElementsByClassName(&quot;link-close&quot;, &quot;a&quot;, <b>this</b>.oDomContainer)[0] || null;

		<b>if</b> (linkClose) {
			YAHOO.util.Event.purgeElement(linkClose);
			<b>this</b>.oDomContainer.removeChild(linkClose);
		}
		<b>if</b> (! title || title === &quot;&quot;) {
			YAHOO.util.Dom.removeClass(<b>this</b>.oDomContainer, &quot;withtitle&quot;);
		}
	}
};

<i>/**
* Initializes Calendar's built-<b>in</b> CustomEvents
* @method initEvents
*/</i>
YAHOO.widget.Calendar.prototype.initEvents = <b>function</b>() {

	<i>/**
	* Fired before a selection is made
	* @event beforeSelectEvent
	*/</i>
	<b>this</b>.beforeSelectEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;beforeSelect&quot;);

	<i>/**
	* Fired when a selection is made
	* @event selectEvent
	* @param {Array}	Array of Date field arrays <b>in</b> the format [YYYY, MM, DD].
	*/</i>
	<b>this</b>.selectEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;select&quot;);

	<i>/**
	* Fired before a selection is made
	* @event beforeDeselectEvent
	*/</i>
	<b>this</b>.beforeDeselectEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;beforeDeselect&quot;);

	<i>/**
	* Fired when a selection is made
	* @event deselectEvent
	* @param {Array}	Array of Date field arrays <b>in</b> the format [YYYY, MM, DD].
	*/</i>
	<b>this</b>.deselectEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;deselect&quot;);

	<i>/**
	* Fired when the Calendar page is changed
	* @event changePageEvent
	*/</i>
	<b>this</b>.changePageEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;changePage&quot;);

	<i>/**
	* Fired before the Calendar is rendered
	* @event beforeRenderEvent
	*/</i>
	<b>this</b>.beforeRenderEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;beforeRender&quot;);

	<i>/**
	* Fired when the Calendar is rendered
	* @event renderEvent
	*/</i>
	<b>this</b>.renderEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;render&quot;);

	<i>/**
	* Fired when the Calendar is reset
	* @event resetEvent
	*/</i>
	<b>this</b>.resetEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;reset&quot;);

	<i>/**
	* Fired when the Calendar is cleared
	* @event clearEvent
	*/</i>
	<b>this</b>.clearEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;clear&quot;);

	<b>this</b>.beforeSelectEvent.subscribe(<b>this</b>.onBeforeSelect, <b>this</b>, true);
	<b>this</b>.selectEvent.subscribe(<b>this</b>.onSelect, <b>this</b>, true);
	<b>this</b>.beforeDeselectEvent.subscribe(<b>this</b>.onBeforeDeselect, <b>this</b>, true);
	<b>this</b>.deselectEvent.subscribe(<b>this</b>.onDeselect, <b>this</b>, true);
	<b>this</b>.changePageEvent.subscribe(<b>this</b>.onChangePage, <b>this</b>, true);
	<b>this</b>.renderEvent.subscribe(<b>this</b>.onRender, <b>this</b>, true);
	<b>this</b>.resetEvent.subscribe(<b>this</b>.onReset, <b>this</b>, true);
	<b>this</b>.clearEvent.subscribe(<b>this</b>.onClear, <b>this</b>, true);
};


<i>/**
* The <b>default</b> event <b>function</b> that is attached to a date link within a calendar cell
* when the calendar is rendered.
* @method doSelectCell
* @param {DOMEvent} e	The event
* @param {Calendar} cal	A reference to the calendar passed by the Event utility
*/</i>
YAHOO.widget.Calendar.prototype.doSelectCell = <b>function</b>(e, cal) {
	<b>var</b> target = YAHOO.util.Event.getTarget(e);

	<b>var</b> cell,index,d,date;

	<b>while</b> (target.tagName.toLowerCase() != &quot;td&quot; &amp;&amp; ! YAHOO.util.Dom.hasClass(target, cal.Style.CSS_CELL_SELECTABLE)) {
		target = target.parentNode;
		<b>if</b> (target.tagName.toLowerCase() == &quot;html&quot;) {
			<b>return</b>;
		}
	}

	cell = target;

	<b>if</b> (YAHOO.util.Dom.hasClass(cell, cal.Style.CSS_CELL_SELECTABLE)) {
		index = cell.id.split(&quot;cell&quot;)[1];
		d = cal.cellDates[index];
		date = <b>new</b> Date(d[0],d[1]-1,d[2]);

		<b>var</b> link;

		<b>if</b> (cal.Options.MULTI_SELECT) {
			link = cell.getElementsByTagName(&quot;a&quot;)[0];
			<b>if</b> (link) {
				link.blur();
			}

			<b>var</b> cellDate = cal.cellDates[index];
			<b>var</b> cellDateIndex = cal._indexOfSelectedFieldArray(cellDate);

			<b>if</b> (cellDateIndex &gt; -1) {
				cal.deselectCell(index);
			} <b>else</b> {
				cal.selectCell(index);
			}

		} <b>else</b> {
			link = cell.getElementsByTagName(&quot;a&quot;)[0];
			<b>if</b> (link) {
				link.blur();
			}
			cal.selectCell(index);
		}
	}
};

<i>/**
* The event that is executed when the user hovers over a cell
* @method doCellMouseOver
* @param {DOMEvent} e	The event
* @param {Calendar} cal	A reference to the calendar passed by the Event utility
*/</i>
YAHOO.widget.Calendar.prototype.doCellMouseOver = <b>function</b>(e, cal) {
	<b>var</b> target;
	<b>if</b> (e) {
		target = YAHOO.util.Event.getTarget(e);
	} <b>else</b> {
		target = <b>this</b>;
	}

	<b>while</b> (target.tagName.toLowerCase() != &quot;td&quot;) {
		target = target.parentNode;
		<b>if</b> (target.tagName.toLowerCase() == &quot;html&quot;) {
			<b>return</b>;
		}
	}

	<b>if</b> (YAHOO.util.Dom.hasClass(target, cal.Style.CSS_CELL_SELECTABLE)) {
		YAHOO.util.Dom.addClass(target, cal.Style.CSS_CELL_HOVER);
	}
};

<i>/**
* The event that is executed when the user moves the mouse out of a cell
* @method doCellMouseOut
* @param {DOMEvent} e	The event
* @param {Calendar} cal	A reference to the calendar passed by the Event utility
*/</i>
YAHOO.widget.Calendar.prototype.doCellMouseOut = <b>function</b>(e, cal) {
	<b>var</b> target;
	<b>if</b> (e) {
		target = YAHOO.util.Event.getTarget(e);
	} <b>else</b> {
		target = <b>this</b>;
	}

	<b>while</b> (target.tagName.toLowerCase() != &quot;td&quot;) {
		target = target.parentNode;
		<b>if</b> (target.tagName.toLowerCase() == &quot;html&quot;) {
			<b>return</b>;
		}
	}

	<b>if</b> (YAHOO.util.Dom.hasClass(target, cal.Style.CSS_CELL_SELECTABLE)) {
		YAHOO.util.Dom.removeClass(target, cal.Style.CSS_CELL_HOVER);
	}
};

YAHOO.widget.Calendar.prototype.setupConfig = <b>function</b>() {

	<i>/**
	* The month/year representing the current visible Calendar date (mm/yyyy)
	* @config pagedate
	* @type String
	* @<b>default</b> today's date
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;pagedate&quot;, { value:<b>new</b> Date(), handler:<b>this</b>.configPageDate } );

	<i>/**
	* The date or range of dates representing the current Calendar selection
	* @config selected
	* @type String
	* @<b>default</b> []
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;selected&quot;, { value:[], handler:<b>this</b>.configSelected } );

	<i>/**
	* The title to display above the Calendar's month header
	* @config title
	* @type String
	* @<b>default</b> &quot;&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;title&quot;, { value:&quot;&quot;, handler:<b>this</b>.configTitle } );

	<i>/**
	* Whether or not a close button should be displayed <b>for</b> this Calendar
	* @config close
	* @type Boolean
	* @<b>default</b> false
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;close&quot;, { value:false, handler:<b>this</b>.configClose } );

	<i>/**
	* Whether or not an iframe shim should be placed under the Calendar to prevent select boxes from bleeding through <b>in</b> Internet Explorer 6 and below.
	* @config iframe
	* @type Boolean
	* @<b>default</b> true
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;iframe&quot;, { value:true, handler:<b>this</b>.configIframe, validator:<b>this</b>.cfg.checkBoolean } );

	<i>/**
	* The minimum selectable date <b>in</b> the current Calendar (mm/dd/yyyy)
	* @config mindate
	* @type String
	* @<b>default</b> null
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;mindate&quot;, { value:null, handler:<b>this</b>.configMinDate } );

	<i>/**
	* The maximum selectable date <b>in</b> the current Calendar (mm/dd/yyyy)
	* @config maxdate
	* @type String
	* @<b>default</b> null
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;maxdate&quot;, { value:null, handler:<b>this</b>.configMaxDate } );


	<i>// Options properties</i>

	<i>/**
	* True <b>if</b> the Calendar should allow multiple selections. False by <b>default</b>.
	* @config MULTI_SELECT
	* @type Boolean
	* @<b>default</b> false
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MULTI_SELECT&quot;,	{ value:false, handler:<b>this</b>.configOptions, validator:<b>this</b>.cfg.checkBoolean } );

	<i>/**
	* The weekday the week begins on. Default is 0 (Sunday).
	* @config START_WEEKDAY
	* @type number
	* @<b>default</b> 0
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;START_WEEKDAY&quot;,	{ value:0, handler:<b>this</b>.configOptions, validator:<b>this</b>.cfg.checkNumber  } );

	<i>/**
	* True <b>if</b> the Calendar should show weekday labels. True by <b>default</b>.
	* @config SHOW_WEEKDAYS
	* @type Boolean
	* @<b>default</b> true
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;SHOW_WEEKDAYS&quot;,	{ value:true, handler:<b>this</b>.configOptions, validator:<b>this</b>.cfg.checkBoolean  } );

	<i>/**
	* True <b>if</b> the Calendar should show week row headers. False by <b>default</b>.
	* @config SHOW_WEEK_HEADER
	* @type Boolean
	* @<b>default</b> false
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;SHOW_WEEK_HEADER&quot;,{ value:false, handler:<b>this</b>.configOptions, validator:<b>this</b>.cfg.checkBoolean } );

	<i>/**
	* True <b>if</b> the Calendar should show week row footers. False by <b>default</b>.
	* @config SHOW_WEEK_FOOTER
	* @type Boolean
	* @<b>default</b> false
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;SHOW_WEEK_FOOTER&quot;,{ value:false, handler:<b>this</b>.configOptions, validator:<b>this</b>.cfg.checkBoolean } );

	<i>/**
	* True <b>if</b> the Calendar should suppress weeks that are not a part of the current month. False by <b>default</b>.
	* @config HIDE_BLANK_WEEKS
	* @type Boolean
	* @<b>default</b> false
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;HIDE_BLANK_WEEKS&quot;,{ value:false, handler:<b>this</b>.configOptions, validator:<b>this</b>.cfg.checkBoolean } );

	<i>/**
	* The image that should be used <b>for</b> the left navigation arrow.
	* @config NAV_ARROW_LEFT
	* @type String
	* @<b>default</b> YAHOO.widget.Calendar.IMG_ROOT + &quot;us/tr/callt.gif&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;NAV_ARROW_LEFT&quot;,	{ value:YAHOO.widget.Calendar.IMG_ROOT + &quot;us/tr/callt.gif&quot;, handler:<b>this</b>.configOptions } );

	<i>/**
	* The image that should be used <b>for</b> the left navigation arrow.
	* @config NAV_ARROW_RIGHT
	* @type String
	* @<b>default</b> YAHOO.widget.Calendar.IMG_ROOT + &quot;us/tr/calrt.gif&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;NAV_ARROW_RIGHT&quot;,	{ value:YAHOO.widget.Calendar.IMG_ROOT + &quot;us/tr/calrt.gif&quot;, handler:<b>this</b>.configOptions } );

	<i>// Locale properties</i>

	<i>/**
	* The short month labels <b>for</b> the current locale.
	* @config MONTHS_SHORT
	* @type String[]
	* @<b>default</b> [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;]
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MONTHS_SHORT&quot;,	{ value:[&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;], handler:<b>this</b>.configLocale } );

	<i>/**
	* The long month labels <b>for</b> the current locale.
	* @config MONTHS_LONG
	* @type String[]
	* @<b>default</b> [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MONTHS_LONG&quot;,		{ value:[&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;], handler:<b>this</b>.configLocale } );

	<i>/**
	* The 1-character weekday labels <b>for</b> the current locale.
	* @config WEEKDAYS_1CHAR
	* @type String[]
	* @<b>default</b> [&quot;S&quot;, &quot;M&quot;, &quot;T&quot;, &quot;W&quot;, &quot;T&quot;, &quot;F&quot;, &quot;S&quot;]
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;WEEKDAYS_1CHAR&quot;,	{ value:[&quot;S&quot;, &quot;M&quot;, &quot;T&quot;, &quot;W&quot;, &quot;T&quot;, &quot;F&quot;, &quot;S&quot;], handler:<b>this</b>.configLocale } );

	<i>/**
	* The short weekday labels <b>for</b> the current locale.
	* @config WEEKDAYS_SHORT
	* @type String[]
	* @<b>default</b> [&quot;Su&quot;, &quot;Mo&quot;, &quot;Tu&quot;, &quot;We&quot;, &quot;Th&quot;, &quot;Fr&quot;, &quot;Sa&quot;]
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;WEEKDAYS_SHORT&quot;,	{ value:[&quot;Su&quot;, &quot;Mo&quot;, &quot;Tu&quot;, &quot;We&quot;, &quot;Th&quot;, &quot;Fr&quot;, &quot;Sa&quot;], handler:<b>this</b>.configLocale } );

	<i>/**
	* The medium weekday labels <b>for</b> the current locale.
	* @config WEEKDAYS_MEDIUM
	* @type String[]
	* @<b>default</b> [&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;]
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;WEEKDAYS_MEDIUM&quot;,	{ value:[&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;], handler:<b>this</b>.configLocale } );

	<i>/**
	* The long weekday labels <b>for</b> the current locale.
	* @config WEEKDAYS_LONG
	* @type String[]
	* @<b>default</b> [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;]
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;WEEKDAYS_LONG&quot;,	{ value:[&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;], handler:<b>this</b>.configLocale } );

	<i>/**
	* Refreshes the locale values used to build the Calendar.
	* @method refreshLocale
	* @private
	*/</i>
	<b>var</b> refreshLocale = <b>function</b>() {
		<b>this</b>.cfg.refireEvent(&quot;LOCALE_MONTHS&quot;);
		<b>this</b>.cfg.refireEvent(&quot;LOCALE_WEEKDAYS&quot;);
	};

	<b>this</b>.cfg.subscribeToConfigEvent(&quot;START_WEEKDAY&quot;, refreshLocale, <b>this</b>, true);
	<b>this</b>.cfg.subscribeToConfigEvent(&quot;MONTHS_SHORT&quot;, refreshLocale, <b>this</b>, true);
	<b>this</b>.cfg.subscribeToConfigEvent(&quot;MONTHS_LONG&quot;, refreshLocale, <b>this</b>, true);
	<b>this</b>.cfg.subscribeToConfigEvent(&quot;WEEKDAYS_1CHAR&quot;, refreshLocale, <b>this</b>, true);
	<b>this</b>.cfg.subscribeToConfigEvent(&quot;WEEKDAYS_SHORT&quot;, refreshLocale, <b>this</b>, true);
	<b>this</b>.cfg.subscribeToConfigEvent(&quot;WEEKDAYS_MEDIUM&quot;, refreshLocale, <b>this</b>, true);
	<b>this</b>.cfg.subscribeToConfigEvent(&quot;WEEKDAYS_LONG&quot;, refreshLocale, <b>this</b>, true);

	<i>/**
	* The setting that determines which length of month labels should be used. Possible values are &quot;short&quot; and &quot;long&quot;.
	* @config LOCALE_MONTHS
	* @type String
	* @<b>default</b> &quot;long&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;LOCALE_MONTHS&quot;,	{ value:&quot;long&quot;, handler:<b>this</b>.configLocaleValues } );

	<i>/**
	* The setting that determines which length of weekday labels should be used. Possible values are &quot;1char&quot;, &quot;short&quot;, &quot;medium&quot;, and &quot;long&quot;.
	* @config LOCALE_WEEKDAYS
	* @type String
	* @<b>default</b> &quot;short&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;LOCALE_WEEKDAYS&quot;,	{ value:&quot;short&quot;, handler:<b>this</b>.configLocaleValues } );

	<i>/**
	* The value used to delimit individual dates <b>in</b> a date string passed to various Calendar functions.
	* @config DATE_DELIMITER
	* @type String
	* @<b>default</b> &quot;,&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;DATE_DELIMITER&quot;,		{ value:&quot;,&quot;, handler:<b>this</b>.configLocale } );

	<i>/**
	* The value used to delimit date fields <b>in</b> a date string passed to various Calendar functions.
	* @config DATE_FIELD_DELIMITER
	* @type String
	* @<b>default</b> &quot;/&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;DATE_FIELD_DELIMITER&quot;,{ value:&quot;/&quot;, handler:<b>this</b>.configLocale } );

	<i>/**
	* The value used to delimit date ranges <b>in</b> a date string passed to various Calendar functions.
	* @config DATE_RANGE_DELIMITER
	* @type String
	* @<b>default</b> &quot;-&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;DATE_RANGE_DELIMITER&quot;,{ value:&quot;-&quot;, handler:<b>this</b>.configLocale } );

	<i>/**
	* The position of the month <b>in</b> a month/year date string
	* @config MY_MONTH_POSITION
	* @type Number
	* @<b>default</b> 1
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MY_MONTH_POSITION&quot;,	{ value:1, handler:<b>this</b>.configLocale, validator:<b>this</b>.cfg.checkNumber } );

	<i>/**
	* The position of the year <b>in</b> a month/year date string
	* @config MY_YEAR_POSITION
	* @type Number
	* @<b>default</b> 2
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MY_YEAR_POSITION&quot;,	{ value:2, handler:<b>this</b>.configLocale, validator:<b>this</b>.cfg.checkNumber } );

	<i>/**
	* The position of the month <b>in</b> a month/day date string
	* @config MD_MONTH_POSITION
	* @type Number
	* @<b>default</b> 1
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MD_MONTH_POSITION&quot;,	{ value:1, handler:<b>this</b>.configLocale, validator:<b>this</b>.cfg.checkNumber } );

	<i>/**
	* The position of the day <b>in</b> a month/year date string
	* @config MD_DAY_POSITION
	* @type Number
	* @<b>default</b> 2
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MD_DAY_POSITION&quot;,		{ value:2, handler:<b>this</b>.configLocale, validator:<b>this</b>.cfg.checkNumber } );

	<i>/**
	* The position of the month <b>in</b> a month/day/year date string
	* @config MDY_MONTH_POSITION
	* @type Number
	* @<b>default</b> 1
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MDY_MONTH_POSITION&quot;,	{ value:1, handler:<b>this</b>.configLocale, validator:<b>this</b>.cfg.checkNumber } );

	<i>/**
	* The position of the day <b>in</b> a month/day/year date string
	* @config MDY_DAY_POSITION
	* @type Number
	* @<b>default</b> 2
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MDY_DAY_POSITION&quot;,	{ value:2, handler:<b>this</b>.configLocale, validator:<b>this</b>.cfg.checkNumber } );

	<i>/**
	* The position of the year <b>in</b> a month/day/year date string
	* @config MDY_YEAR_POSITION
	* @type Number
	* @<b>default</b> 3
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MDY_YEAR_POSITION&quot;,	{ value:3, handler:<b>this</b>.configLocale, validator:<b>this</b>.cfg.checkNumber } );
};

<i>/**
* The <b>default</b> handler <b>for</b> the &quot;pagedate&quot; property
* @method configPageDate
*/</i>
YAHOO.widget.Calendar.prototype.configPageDate = <b>function</b>(type, args, obj) {
	<b>var</b> val = args[0];
	<b>var</b> month, year, aMonthYear;

	<b>if</b> (val) {
		<b>if</b> (val instanceof Date) {
			val = YAHOO.widget.DateMath.findMonthStart(val);
			<b>this</b>.cfg.setProperty(&quot;pagedate&quot;, val, true);
			<b>if</b> (! <b>this</b>._pageDate) {
				<b>this</b>._pageDate = <b>this</b>.cfg.getProperty(&quot;pagedate&quot;);
			}
			<b>return</b>;
		} <b>else</b> {
			aMonthYear = val.split(<b>this</b>.cfg.getProperty(&quot;DATE_FIELD_DELIMITER&quot;));
			month = parseInt(aMonthYear[<b>this</b>.cfg.getProperty(&quot;MY_MONTH_POSITION&quot;)-1], 10)-1;
			year = parseInt(aMonthYear[<b>this</b>.cfg.getProperty(&quot;MY_YEAR_POSITION&quot;)-1], 10);
		}
	} <b>else</b> {
		month = <b>this</b>.today.getMonth();
		year = <b>this</b>.today.getFullYear();
	}

	<b>this</b>.cfg.setProperty(&quot;pagedate&quot;, <b>new</b> Date(year, month, 1), true);
	<b>if</b> (! <b>this</b>._pageDate) {
		<b>this</b>._pageDate = <b>this</b>.cfg.getProperty(&quot;pagedate&quot;);
	}
};

<i>/**
* The <b>default</b> handler <b>for</b> the &quot;mindate&quot; property
* @method configMinDate
*/</i>
YAHOO.widget.Calendar.prototype.configMinDate = <b>function</b>(type, args, obj) {
	<b>var</b> val = args[0];
	<b>if</b> (<b>typeof</b> val == 'string') {
		val = <b>this</b>._parseDate(val);
		<b>this</b>.cfg.setProperty(&quot;mindate&quot;, <b>new</b> Date(val[0],(val[1]-1),val[2]));
	}
};

<i>/**
* The <b>default</b> handler <b>for</b> the &quot;maxdate&quot; property
* @method configMaxDate
*/</i>
YAHOO.widget.Calendar.prototype.configMaxDate = <b>function</b>(type, args, obj) {
	<b>var</b> val = args[0];
	<b>if</b> (<b>typeof</b> val == 'string') {
		val = <b>this</b>._parseDate(val);
		<b>this</b>.cfg.setProperty(&quot;maxdate&quot;, <b>new</b> Date(val[0],(val[1]-1),val[2]));
	}
};

<i>/**
* The <b>default</b> handler <b>for</b> the &quot;selected&quot; property
* @method configSelected
*/</i>
YAHOO.widget.Calendar.prototype.configSelected = <b>function</b>(type, args, obj) {
	<b>var</b> selected = args[0];

	<b>if</b> (selected) {
		<b>if</b> (<b>typeof</b> selected == 'string') {
			<b>this</b>.cfg.setProperty(&quot;selected&quot;, <b>this</b>._parseDates(selected), true);
		}
	}
	<b>if</b> (! <b>this</b>._selectedDates) {
		<b>this</b>._selectedDates = <b>this</b>.cfg.getProperty(&quot;selected&quot;);
	}
};

<i>/**
* The <b>default</b> handler <b>for</b> all configuration options properties
* @method configOptions
*/</i>
YAHOO.widget.Calendar.prototype.configOptions = <b>function</b>(type, args, obj) {
	type = type.toUpperCase();
	<b>var</b> val = args[0];
	<b>this</b>.Options[type] = val;
};

<i>/**
* The <b>default</b> handler <b>for</b> all configuration locale properties
* @method configLocale
*/</i>
YAHOO.widget.Calendar.prototype.configLocale = <b>function</b>(type, args, obj) {
	type = type.toUpperCase();
	<b>var</b> val = args[0];
	<b>this</b>.Locale[type] = val;

	<b>this</b>.cfg.refireEvent(&quot;LOCALE_MONTHS&quot;);
	<b>this</b>.cfg.refireEvent(&quot;LOCALE_WEEKDAYS&quot;);

};

<i>/**
* The <b>default</b> handler <b>for</b> all configuration locale field length properties
* @method configLocaleValues
*/</i>
YAHOO.widget.Calendar.prototype.configLocaleValues = <b>function</b>(type, args, obj) {
	type = type.toUpperCase();
	<b>var</b> val = args[0];

	<b>switch</b> (type) {
		<b>case</b> &quot;LOCALE_MONTHS&quot;:
			<b>switch</b> (val) {
				<b>case</b> &quot;short&quot;:
					<b>this</b>.Locale.LOCALE_MONTHS = <b>this</b>.cfg.getProperty(&quot;MONTHS_SHORT&quot;).concat();
					<b>break</b>;
				<b>case</b> &quot;long&quot;:
					<b>this</b>.Locale.LOCALE_MONTHS = <b>this</b>.cfg.getProperty(&quot;MONTHS_LONG&quot;).concat();
					<b>break</b>;
			}
			<b>break</b>;
		<b>case</b> &quot;LOCALE_WEEKDAYS&quot;:
			<b>switch</b> (val) {
				<b>case</b> &quot;1char&quot;:
					<b>this</b>.Locale.LOCALE_WEEKDAYS = <b>this</b>.cfg.getProperty(&quot;WEEKDAYS_1CHAR&quot;).concat();
					<b>break</b>;
				<b>case</b> &quot;short&quot;:
					<b>this</b>.Locale.LOCALE_WEEKDAYS = <b>this</b>.cfg.getProperty(&quot;WEEKDAYS_SHORT&quot;).concat();
					<b>break</b>;
				<b>case</b> &quot;medium&quot;:
					<b>this</b>.Locale.LOCALE_WEEKDAYS = <b>this</b>.cfg.getProperty(&quot;WEEKDAYS_MEDIUM&quot;).concat();
					<b>break</b>;
				<b>case</b> &quot;long&quot;:
					<b>this</b>.Locale.LOCALE_WEEKDAYS = <b>this</b>.cfg.getProperty(&quot;WEEKDAYS_LONG&quot;).concat();
					<b>break</b>;
			}

			<b>var</b> START_WEEKDAY = <b>this</b>.cfg.getProperty(&quot;START_WEEKDAY&quot;);

			<b>if</b> (START_WEEKDAY &gt; 0) {
				<b>for</b> (<b>var</b> w=0;w&lt;START_WEEKDAY;++w) {
					<b>this</b>.Locale.LOCALE_WEEKDAYS.push(<b>this</b>.Locale.LOCALE_WEEKDAYS.shift());
				}
			}
			<b>break</b>;
	}
};

<i>/**
* Defines the style constants <b>for</b> the Calendar
* @method initStyles
*/</i>
YAHOO.widget.Calendar.prototype.initStyles = <b>function</b>() {

	<i>/**
	* Collection of Style constants <b>for</b> the Calendar
	* @property Style
	*/</i>
	<b>this</b>.Style = {
		<i>/**
		* @property Style.CSS_ROW_HEADER
		*/</i>
		CSS_ROW_HEADER: &quot;calrowhead&quot;,
		<i>/**
		* @property Style.CSS_ROW_FOOTER
		*/</i>
		CSS_ROW_FOOTER: &quot;calrowfoot&quot;,
		<i>/**
		* @property Style.CSS_CELL
		*/</i>
		CSS_CELL : &quot;calcell&quot;,
		<i>/**
		* @property Style.CSS_CELL_SELECTED
		*/</i>
		CSS_CELL_SELECTED : &quot;selected&quot;,
		<i>/**
		* @property Style.CSS_CELL_SELECTABLE
		*/</i>
		CSS_CELL_SELECTABLE : &quot;selectable&quot;,
		<i>/**
		* @property Style.CSS_CELL_RESTRICTED
		*/</i>
		CSS_CELL_RESTRICTED : &quot;restricted&quot;,
		<i>/**
		* @property Style.CSS_CELL_TODAY
		*/</i>
		CSS_CELL_TODAY : &quot;today&quot;,
		<i>/**
		* @property Style.CSS_CELL_OOM
		*/</i>
		CSS_CELL_OOM : &quot;oom&quot;,
		<i>/**
		* @property Style.CSS_CELL_OOB
		*/</i>
		CSS_CELL_OOB : &quot;previous&quot;,
		<i>/**
		* @property Style.CSS_HEADER
		*/</i>
		CSS_HEADER : &quot;calheader&quot;,
		<i>/**
		* @property Style.CSS_HEADER_TEXT
		*/</i>
		CSS_HEADER_TEXT : &quot;calhead&quot;,
		<i>/**
		* @property Style.CSS_WEEKDAY_CELL
		*/</i>
		CSS_WEEKDAY_CELL : &quot;calweekdaycell&quot;,
		<i>/**
		* @property Style.CSS_WEEKDAY_ROW
		*/</i>
		CSS_WEEKDAY_ROW : &quot;calweekdayrow&quot;,
		<i>/**
		* @property Style.CSS_FOOTER
		*/</i>
		CSS_FOOTER : &quot;calfoot&quot;,
		<i>/**
		* @property Style.CSS_CALENDAR
		*/</i>
		CSS_CALENDAR : &quot;yui-calendar&quot;,
		<i>/**
		* @property Style.CSS_SINGLE
		*/</i>
		CSS_SINGLE : &quot;single&quot;,
		<i>/**
		* @property Style.CSS_CONTAINER
		*/</i>
		CSS_CONTAINER : &quot;yui-calcontainer&quot;,
		<i>/**
		* @property Style.CSS_NAV_LEFT
		*/</i>
		CSS_NAV_LEFT : &quot;calnavleft&quot;,
		<i>/**
		* @property Style.CSS_NAV_RIGHT
		*/</i>
		CSS_NAV_RIGHT : &quot;calnavright&quot;,
		<i>/**
		* @property Style.CSS_CELL_TOP
		*/</i>
		CSS_CELL_TOP : &quot;calcelltop&quot;,
		<i>/**
		* @property Style.CSS_CELL_LEFT
		*/</i>
		CSS_CELL_LEFT : &quot;calcellleft&quot;,
		<i>/**
		* @property Style.CSS_CELL_RIGHT
		*/</i>
		CSS_CELL_RIGHT : &quot;calcellright&quot;,
		<i>/**
		* @property Style.CSS_CELL_BOTTOM
		*/</i>
		CSS_CELL_BOTTOM : &quot;calcellbottom&quot;,
		<i>/**
		* @property Style.CSS_CELL_HOVER
		*/</i>
		CSS_CELL_HOVER : &quot;calcellhover&quot;,
		<i>/**
		* @property Style.CSS_CELL_HIGHLIGHT1
		*/</i>
		CSS_CELL_HIGHLIGHT1 : &quot;highlight1&quot;,
		<i>/**
		* @property Style.CSS_CELL_HIGHLIGHT2
		*/</i>
		CSS_CELL_HIGHLIGHT2 : &quot;highlight2&quot;,
		<i>/**
		* @property Style.CSS_CELL_HIGHLIGHT3
		*/</i>
		CSS_CELL_HIGHLIGHT3 : &quot;highlight3&quot;,
		<i>/**
		* @property Style.CSS_CELL_HIGHLIGHT4
		*/</i>
		CSS_CELL_HIGHLIGHT4 : &quot;highlight4&quot;
	};
};

<i>/**
* Builds the date label that will be displayed <b>in</b> the calendar header or
* footer, depending on configuration.
* @method buildMonthLabel
* @<b>return</b>	{String}	The formatted calendar month label
*/</i>
YAHOO.widget.Calendar.prototype.buildMonthLabel = <b>function</b>() {
	<b>var</b> text = <b>this</b>.Locale.LOCALE_MONTHS[<b>this</b>.cfg.getProperty(&quot;pagedate&quot;).getMonth()] + &quot; &quot; + <b>this</b>.cfg.getProperty(&quot;pagedate&quot;).getFullYear();
	<b>return</b> text;
};

<i>/**
* Builds the date digit that will be displayed <b>in</b> calendar cells
* @method buildDayLabel
* @param {Date}	workingDate	The current working date
* @<b>return</b>	{String}	The formatted day label
*/</i>
YAHOO.widget.Calendar.prototype.buildDayLabel = <b>function</b>(workingDate) {
	<b>var</b> day = workingDate.getDate();
	<b>return</b> day;
};

<i>/**
* Renders the calendar header.
* @method renderHeader
* @param {Array}	html	The current working HTML array
* @<b>return</b> {Array} The current working HTML array
*/</i>
YAHOO.widget.Calendar.prototype.renderHeader = <b>function</b>(html) {
	<b>var</b> colSpan = 7;

	<b>if</b> (<b>this</b>.cfg.getProperty(&quot;SHOW_WEEK_HEADER&quot;)) {
		colSpan += 1;
	}

	<b>if</b> (<b>this</b>.cfg.getProperty(&quot;SHOW_WEEK_FOOTER&quot;)) {
		colSpan += 1;
	}

	html[html.length] = &quot;&lt;thead&gt;&quot;;
	html[html.length] =		&quot;&lt;tr&gt;&quot;;
	html[html.length] =			'&lt;th colspan=&quot;' + colSpan + '&quot; class=&quot;' + <b>this</b>.Style.CSS_HEADER_TEXT + '&quot;&gt;';
	html[html.length] =				'&lt;div class=&quot;' + <b>this</b>.Style.CSS_HEADER + '&quot;&gt;';

		<b>var</b> renderLeft, renderRight = false;

		<b>if</b> (<b>this</b>.parent) {
			<b>if</b> (<b>this</b>.index === 0) {
				renderLeft = true;
			}
			<b>if</b> (<b>this</b>.index == (<b>this</b>.parent.cfg.getProperty(&quot;pages&quot;) -1)) {
				renderRight = true;
			}
		} <b>else</b> {
			renderLeft = true;
			renderRight = true;
		}

		<b>var</b> cal = <b>this</b>.parent || <b>this</b>;

		<b>if</b> (renderLeft) {
			html[html.length] = '&lt;a class=&quot;' + <b>this</b>.Style.CSS_NAV_LEFT + '&quot; style=&quot;background-image:url(' + <b>this</b>.cfg.getProperty(&quot;NAV_ARROW_LEFT&quot;) + ')&quot;&gt;&amp;#160;&lt;/a&gt;';
		}

		html[html.length] = <b>this</b>.buildMonthLabel();

		<b>if</b> (renderRight) {
			html[html.length] = '&lt;a class=&quot;' + <b>this</b>.Style.CSS_NAV_RIGHT + '&quot; style=&quot;background-image:url(' + <b>this</b>.cfg.getProperty(&quot;NAV_ARROW_RIGHT&quot;) + ')&quot;&gt;&amp;#160;&lt;/a&gt;';
		}


	html[html.length] =				'&lt;/div&gt;';
	html[html.length] =			'&lt;/th&gt;';
	html[html.length] =		'&lt;/tr&gt;';

	<b>if</b> (<b>this</b>.cfg.getProperty(&quot;SHOW_WEEKDAYS&quot;)) {
		html = <b>this</b>.buildWeekdays(html);
	}

	html[html.length] = '&lt;/thead&gt;';

	<b>return</b> html;
};

<i>/**
* Renders the Calendar's weekday headers.
* @method buildWeekdays
* @param {Array}	html	The current working HTML array
* @<b>return</b> {Array} The current working HTML array
*/</i>
YAHOO.widget.Calendar.prototype.buildWeekdays = <b>function</b>(html) {

	html[html.length] = '&lt;tr class=&quot;' + <b>this</b>.Style.CSS_WEEKDAY_ROW + '&quot;&gt;';

	<b>if</b> (<b>this</b>.cfg.getProperty(&quot;SHOW_WEEK_HEADER&quot;)) {
		html[html.length] = '&lt;th&gt;&amp;#160;&lt;/th&gt;';
	}

	<b>for</b>(var i=0;i&lt;<b>this</b>.Locale.LOCALE_WEEKDAYS.length;++i) {
		html[html.length] = '&lt;th class=&quot;calweekdaycell&quot;&gt;' + <b>this</b>.Locale.LOCALE_WEEKDAYS[i] + '&lt;/th&gt;';
	}

	<b>if</b> (<b>this</b>.cfg.getProperty(&quot;SHOW_WEEK_FOOTER&quot;)) {
		html[html.length] = '&lt;th&gt;&amp;#160;&lt;/th&gt;';
	}

	html[html.length] = '&lt;/tr&gt;';

	<b>return</b> html;
};

<i>/**
* Renders the calendar body.
* @method renderBody
* @param {Date}	workingDate	The current working Date being used <b>for</b> the render process
* @param {Array}	html	The current working HTML array
* @<b>return</b> {Array} The current working HTML array
*/</i>
YAHOO.widget.Calendar.prototype.renderBody = <b>function</b>(workingDate, html) {

	<b>var</b> startDay = <b>this</b>.cfg.getProperty(&quot;START_WEEKDAY&quot;);

	<b>this</b>.preMonthDays = workingDate.getDay();
	<b>if</b> (startDay &gt; 0) {
		<b>this</b>.preMonthDays -= startDay;
	}
	<b>if</b> (<b>this</b>.preMonthDays &lt; 0) {
		<b>this</b>.preMonthDays += 7;
	}

	<b>this</b>.monthDays = YAHOO.widget.DateMath.findMonthEnd(workingDate).getDate();
	<b>this</b>.postMonthDays = YAHOO.widget.Calendar.DISPLAY_DAYS-<b>this</b>.preMonthDays-<b>this</b>.monthDays;

	workingDate = YAHOO.widget.DateMath.subtract(workingDate, YAHOO.widget.DateMath.DAY, <b>this</b>.preMonthDays);

	<b>var</b> useDate,weekNum,weekClass;
	useDate = <b>this</b>.cfg.getProperty(&quot;pagedate&quot;);

	html[html.length] = '&lt;tbody class=&quot;m' + (useDate.getMonth()+1) + '&quot;&gt;';

	<b>var</b> i = 0;

	<b>var</b> tempDiv = document.createElement(&quot;div&quot;);
	<b>var</b> cell = document.createElement(&quot;td&quot;);
	tempDiv.appendChild(cell);

	<b>var</b> jan1 = <b>new</b> Date(useDate.getFullYear(),0,1);

	<b>var</b> cal = <b>this</b>.parent || <b>this</b>;

	<b>for</b> (<b>var</b> r=0;r&lt;6;r++) {

		weekNum = YAHOO.widget.DateMath.getWeekNumber(workingDate, useDate.getFullYear(), startDay);

		weekClass = &quot;w&quot; + weekNum;

		<b>if</b> (r !== 0 &amp;&amp; <b>this</b>.isDateOOM(workingDate) &amp;&amp; <b>this</b>.cfg.getProperty(&quot;HIDE_BLANK_WEEKS&quot;) === true) {
			<b>break</b>;
		} <b>else</b> {

			html[html.length] = '&lt;tr class=&quot;' + weekClass + '&quot;&gt;';

			<b>if</b> (<b>this</b>.cfg.getProperty(&quot;SHOW_WEEK_HEADER&quot;)) { html = <b>this</b>.renderRowHeader(weekNum, html); }

			<b>for</b> (<b>var</b> d=0;d&lt;7;d++){ <i>// Render actual days</i>

				<b>var</b> cellRenderers = [];

				<b>this</b>.clearElement(cell);

				YAHOO.util.Dom.addClass(cell, &quot;calcell&quot;);

				cell.id = <b>this</b>.id + &quot;_cell&quot; + i;

				cell.innerHTML = i;

				<b>var</b> renderer = null;

				<b>if</b> (workingDate.getFullYear()	== <b>this</b>.today.getFullYear() &amp;&amp;
					workingDate.getMonth()		== <b>this</b>.today.getMonth() &amp;&amp;
					workingDate.getDate()		== <b>this</b>.today.getDate()) {
					cellRenderers[cellRenderers.length]=cal.renderCellStyleToday;
				}

				<b>this</b>.cellDates[<b>this</b>.cellDates.length]=[workingDate.getFullYear(),workingDate.getMonth()+1,workingDate.getDate()]; <i>// Add <b>this</b> date to cellDates</i>

				<b>if</b> (<b>this</b>.isDateOOM(workingDate)) {
					cellRenderers[cellRenderers.length]=cal.renderCellNotThisMonth;
				} <b>else</b> {

					YAHOO.util.Dom.addClass(cell, &quot;wd&quot; + workingDate.getDay());
					YAHOO.util.Dom.addClass(cell, &quot;d&quot; + workingDate.getDate());

					<b>for</b> (<b>var</b> s=0;s&lt;<b>this</b>.renderStack.length;++s) {

						<b>var</b> rArray = <b>this</b>.renderStack[s];
						<b>var</b> type = rArray[0];

						<b>var</b> month;
						<b>var</b> day;
						<b>var</b> year;

						<b>switch</b> (type) {
							<b>case</b> YAHOO.widget.Calendar.DATE:
								month = rArray[1][1];
								day = rArray[1][2];
								year = rArray[1][0];

								<b>if</b> (workingDate.getMonth()+1 == month &amp;&amp; workingDate.getDate() == day &amp;&amp; workingDate.getFullYear() == year) {
									renderer = rArray[2];
									<b>this</b>.renderStack.splice(s,1);
								}
								<b>break</b>;
							<b>case</b> YAHOO.widget.Calendar.MONTH_DAY:
								month = rArray[1][0];
								day = rArray[1][1];

								<b>if</b> (workingDate.getMonth()+1 == month &amp;&amp; workingDate.getDate() == day) {
									renderer = rArray[2];
									<b>this</b>.renderStack.splice(s,1);
								}
								<b>break</b>;
							<b>case</b> YAHOO.widget.Calendar.RANGE:
								<b>var</b> date1 = rArray[1][0];
								<b>var</b> date2 = rArray[1][1];

								<b>var</b> d1month = date1[1];
								<b>var</b> d1day = date1[2];
								<b>var</b> d1year = date1[0];

								<b>var</b> d1 = <b>new</b> Date(d1year, d1month-1, d1day);

								<b>var</b> d2month = date2[1];
								<b>var</b> d2day = date2[2];
								<b>var</b> d2year = date2[0];

								<b>var</b> d2 = <b>new</b> Date(d2year, d2month-1, d2day);

								<b>if</b> (workingDate.getTime() &gt;= d1.getTime() &amp;&amp; workingDate.getTime() &lt;= d2.getTime()) {
									renderer = rArray[2];

									<b>if</b> (workingDate.getTime()==d2.getTime()) {
										<b>this</b>.renderStack.splice(s,1);
									}
								}
								<b>break</b>;
							<b>case</b> YAHOO.widget.Calendar.WEEKDAY:

								<b>var</b> weekday = rArray[1][0];
								<b>if</b> (workingDate.getDay()+1 == weekday) {
									renderer = rArray[2];
								}
								<b>break</b>;
							<b>case</b> YAHOO.widget.Calendar.MONTH:

								month = rArray[1][0];
								<b>if</b> (workingDate.getMonth()+1 == month) {
									renderer = rArray[2];
								}
								<b>break</b>;
						}

						<b>if</b> (renderer) {
							cellRenderers[cellRenderers.length]=renderer;
						}
					}

				}

				<b>if</b> (<b>this</b>._indexOfSelectedFieldArray([workingDate.getFullYear(),workingDate.getMonth()+1,workingDate.getDate()]) &gt; -1) {
					cellRenderers[cellRenderers.length]=cal.renderCellStyleSelected;
				}

				<b>var</b> mindate = <b>this</b>.cfg.getProperty(&quot;mindate&quot;);
				<b>var</b> maxdate = <b>this</b>.cfg.getProperty(&quot;maxdate&quot;);

				<b>if</b> (mindate) {
					mindate = YAHOO.widget.DateMath.clearTime(mindate);
				}
				<b>if</b> (maxdate) {
					maxdate = YAHOO.widget.DateMath.clearTime(maxdate);
				}

				<b>if</b> (
					(mindate &amp;&amp; (workingDate.getTime() &lt; mindate.getTime())) ||
					(maxdate &amp;&amp; (workingDate.getTime() &gt; maxdate.getTime()))
				) {
					cellRenderers[cellRenderers.length]=cal.renderOutOfBoundsDate;
				} <b>else</b> {
					cellRenderers[cellRenderers.length]=cal.styleCellDefault;
					cellRenderers[cellRenderers.length]=cal.renderCellDefault;
				}



				<b>for</b> (<b>var</b> x=0;x&lt;cellRenderers.length;++x) {
					<b>var</b> ren = cellRenderers[x];
					<b>if</b> (ren.call((<b>this</b>.parent || <b>this</b>),workingDate,cell) == YAHOO.widget.Calendar.STOP_RENDER) {
						<b>break</b>;
					}
				}

				workingDate.setTime(workingDate.getTime() + YAHOO.widget.DateMath.ONE_DAY_MS);

				<b>if</b> (i &gt;= 0 &amp;&amp; i &lt;= 6) {
					YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_TOP);
				}
				<b>if</b> ((i % 7) === 0) {
					YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_LEFT);
				}
				<b>if</b> (((i+1) % 7) === 0) {
					YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_RIGHT);
				}

				<b>var</b> postDays = <b>this</b>.postMonthDays;
				<b>if</b> (postDays &gt;= 7 &amp;&amp; <b>this</b>.cfg.getProperty(&quot;HIDE_BLANK_WEEKS&quot;)) {
					<b>var</b> blankWeeks = Math.floor(postDays/7);
					<b>for</b> (<b>var</b> p=0;p&lt;blankWeeks;++p) {
						postDays -= 7;
					}
				}

				<b>if</b> (i &gt;= ((<b>this</b>.preMonthDays+postDays+<b>this</b>.monthDays)-7)) {
					YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_BOTTOM);
				}

				html[html.length] = tempDiv.innerHTML;

				i++;
			}

			<b>if</b> (<b>this</b>.cfg.getProperty(&quot;SHOW_WEEK_FOOTER&quot;)) { html = <b>this</b>.renderRowFooter(weekNum, html); }

			html[html.length] = '&lt;/tr&gt;';
		}
	}

	html[html.length] = '&lt;/tbody&gt;';

	<b>return</b> html;
};

<i>/**
* Renders the calendar footer. In the <b>default</b> implementation, there is
* no footer.
* @method renderFooter
* @param {Array}	html	The current working HTML array
* @<b>return</b> {Array} The current working HTML array
*/</i>
YAHOO.widget.Calendar.prototype.renderFooter = <b>function</b>(html) { <b>return</b> html; };

<i>/**
* Renders the calendar after it has been configured. The render() method has a specific call chain that will execute
* when the method is called: renderHeader, renderBody, renderFooter.
* Refer to the documentation <b>for</b> those methods <b>for</b> information on
* individual render tasks.
* @method render
*/</i>
YAHOO.widget.Calendar.prototype.render = <b>function</b>() {
	<b>this</b>.beforeRenderEvent.fire();

	<i>// Find starting day of the current month</i>
	<b>var</b> workingDate = YAHOO.widget.DateMath.findMonthStart(<b>this</b>.cfg.getProperty(&quot;pagedate&quot;));

	<b>this</b>.resetRenderers();
	<b>this</b>.cellDates.length = 0;

	YAHOO.util.Event.purgeElement(<b>this</b>.oDomContainer, true);

	<b>var</b> html = [];

	html[html.length] = '&lt;table cellSpacing=&quot;0&quot; class=&quot;' + <b>this</b>.Style.CSS_CALENDAR + ' y' + workingDate.getFullYear() + '&quot; id=&quot;' + <b>this</b>.id + '&quot;&gt;';
	html = <b>this</b>.renderHeader(html);
	html = <b>this</b>.renderBody(workingDate, html);
	html = <b>this</b>.renderFooter(html);
	html[html.length] = '&lt;/table&gt;';

	<b>this</b>.oDomContainer.innerHTML = html.join(&quot;\n&quot;);

	<b>this</b>.applyListeners();
	<b>this</b>.cells = <b>this</b>.oDomContainer.getElementsByTagName(&quot;td&quot;);

	<b>this</b>.cfg.refireEvent(&quot;title&quot;);
	<b>this</b>.cfg.refireEvent(&quot;close&quot;);
	<b>this</b>.cfg.refireEvent(&quot;iframe&quot;);

	<b>this</b>.renderEvent.fire();
};

<i>/**
* Applies the Calendar's DOM listeners to applicable elements.
* @method applyListeners
*/</i>
YAHOO.widget.Calendar.prototype.applyListeners = <b>function</b>() {

	<b>var</b> root = <b>this</b>.oDomContainer;
	<b>var</b> cal = <b>this</b>.parent || <b>this</b>;

	<b>var</b> linkLeft, linkRight;

	linkLeft = YAHOO.util.Dom.getElementsByClassName(<b>this</b>.Style.CSS_NAV_LEFT, &quot;a&quot;, root);
	linkRight = YAHOO.util.Dom.getElementsByClassName(<b>this</b>.Style.CSS_NAV_RIGHT, &quot;a&quot;, root);

	<b>if</b> (linkLeft) {
		<b>this</b>.linkLeft = linkLeft[0];
		YAHOO.util.Event.addListener(<b>this</b>.linkLeft, &quot;mousedown&quot;, cal.previousMonth, cal, true);
	}

	<b>if</b> (linkRight) {
		<b>this</b>.linkRight = linkRight[0];
		YAHOO.util.Event.addListener(<b>this</b>.linkRight, &quot;mousedown&quot;, cal.nextMonth, cal, true);
	}

	<b>if</b> (<b>this</b>.domEventMap) {
		<b>var</b> el,elements;
		<b>for</b> (<b>var</b> cls <b>in</b> this.domEventMap) {
			<b>if</b> (<b>this</b>.domEventMap.hasOwnProperty(cls)) {
				<b>var</b> items = <b>this</b>.domEventMap[cls];

				<b>if</b> (! (items instanceof Array)) {
					items = [items];
				}

				<b>for</b> (<b>var</b> i=0;i&lt;items.length;i++)	{
					<b>var</b> item = items[i];
					elements = YAHOO.util.Dom.getElementsByClassName(cls, item.tag, <b>this</b>.oDomContainer);

					<b>for</b> (<b>var</b> c=0;c&lt;elements.length;c++) {
						el = elements[c];
						 YAHOO.util.Event.addListener(el, item.event, item.handler, item.scope, item.correct );
					}
				}
			}
		}
	}

	YAHOO.util.Event.addListener(<b>this</b>.oDomContainer, &quot;click&quot;, <b>this</b>.doSelectCell, <b>this</b>);
	YAHOO.util.Event.addListener(<b>this</b>.oDomContainer, &quot;mouseover&quot;, <b>this</b>.doCellMouseOver, <b>this</b>);
	YAHOO.util.Event.addListener(<b>this</b>.oDomContainer, &quot;mouseout&quot;, <b>this</b>.doCellMouseOut, <b>this</b>);
};

<i>/**
* Retrieves the Date object <b>for</b> the specified Calendar cell
* @method getDateByCellId
* @param {String}	id	The id of the cell
* @<b>return</b> {Date} The Date object <b>for</b> the specified Calendar cell
*/</i>
YAHOO.widget.Calendar.prototype.getDateByCellId = <b>function</b>(id) {
	<b>var</b> date = <b>this</b>.getDateFieldsByCellId(id);
	<b>return</b> new Date(date[0],date[1]-1,date[2]);
};

<i>/**
* Retrieves the Date object <b>for</b> the specified Calendar cell
* @method getDateFieldsByCellId
* @param {String}	id	The id of the cell
* @<b>return</b> {Array}	The array of Date fields <b>for</b> the specified Calendar cell
*/</i>
YAHOO.widget.Calendar.prototype.getDateFieldsByCellId = <b>function</b>(id) {
	id = id.toLowerCase().split(&quot;_cell&quot;)[1];
	id = parseInt(id, 10);
	<b>return</b> this.cellDates[id];
};

<i>// BEGIN BUILT-IN TABLE CELL RENDERERS</i>

<i>/**
* Renders a cell that falls before the minimum date or after the maximum date.
* widget class.
* @method renderOutOfBoundsDate
* @param {Date}					workingDate		The current working Date object being used to generate the calendar
* @param {HTMLTableCellElement}	cell			The current working cell <b>in</b> the calendar
* @<b>return</b> {String} YAHOO.widget.Calendar.STOP_RENDER <b>if</b> rendering should stop <b>with</b> this style, null or nothing <b>if</b> rendering
*			should not be terminated
*/</i>
YAHOO.widget.Calendar.prototype.renderOutOfBoundsDate = <b>function</b>(workingDate, cell) {
	YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_OOB);
	cell.innerHTML = workingDate.getDate();
	<b>return</b> YAHOO.widget.Calendar.STOP_RENDER;
};

<i>/**
* Renders the row header <b>for</b> a week.
* @method renderRowHeader
* @param {Number}	weekNum	The week number of the current row
* @param {Array}	cell	The current working HTML array
*/</i>
YAHOO.widget.Calendar.prototype.renderRowHeader = <b>function</b>(weekNum, html) {
	html[html.length] = '&lt;th class=&quot;calrowhead&quot;&gt;' + weekNum + '&lt;/th&gt;';
	<b>return</b> html;
};

<i>/**
* Renders the row footer <b>for</b> a week.
* @method renderRowFooter
* @param {Number}	weekNum	The week number of the current row
* @param {Array}	cell	The current working HTML array
*/</i>
YAHOO.widget.Calendar.prototype.renderRowFooter = <b>function</b>(weekNum, html) {
	html[html.length] = '&lt;th class=&quot;calrowfoot&quot;&gt;' + weekNum + '&lt;/th&gt;';
	<b>return</b> html;
};

<i>/**
* Renders a single standard calendar cell <b>in</b> the calendar widget table.
* All logic <b>for</b> determining how a standard <b>default</b> cell will be rendered is
* encapsulated <b>in</b> this method, and must be accounted <b>for</b> when extending the
* widget class.
* @method renderCellDefault
* @param {Date}					workingDate		The current working Date object being used to generate the calendar
* @param {HTMLTableCellElement}	cell			The current working cell <b>in</b> the calendar
*/</i>
YAHOO.widget.Calendar.prototype.renderCellDefault = <b>function</b>(workingDate, cell) {
	cell.innerHTML = '&lt;a href=&quot;javascript:<b>void</b>(null);&quot; &gt;' + <b>this</b>.buildDayLabel(workingDate) + &quot;&lt;/a&gt;&quot;;
};

<i>/**
* Styles a selectable cell.
* @method styleCellDefault
* @param {Date}					workingDate		The current working Date object being used to generate the calendar
* @param {HTMLTableCellElement}	cell			The current working cell <b>in</b> the calendar
*/</i>
YAHOO.widget.Calendar.prototype.styleCellDefault = <b>function</b>(workingDate, cell) {
	YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_SELECTABLE);
};


<i>/**
* Renders a single standard calendar cell using the CSS hightlight1 style
* @method renderCellStyleHighlight1
* @param {Date}					workingDate		The current working Date object being used to generate the calendar
* @param {HTMLTableCellElement}	cell			The current working cell <b>in</b> the calendar
*/</i>
YAHOO.widget.Calendar.prototype.renderCellStyleHighlight1 = <b>function</b>(workingDate, cell) {
	YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_HIGHLIGHT1);
};

<i>/**
* Renders a single standard calendar cell using the CSS hightlight2 style
* @method renderCellStyleHighlight2
* @param {Date}					workingDate		The current working Date object being used to generate the calendar
* @param {HTMLTableCellElement}	cell			The current working cell <b>in</b> the calendar
*/</i>
YAHOO.widget.Calendar.prototype.renderCellStyleHighlight2 = <b>function</b>(workingDate, cell) {
	YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_HIGHLIGHT2);
};

<i>/**
* Renders a single standard calendar cell using the CSS hightlight3 style
* @method renderCellStyleHighlight3
* @param {Date}					workingDate		The current working Date object being used to generate the calendar
* @param {HTMLTableCellElement}	cell			The current working cell <b>in</b> the calendar
*/</i>
YAHOO.widget.Calendar.prototype.renderCellStyleHighlight3 = <b>function</b>(workingDate, cell) {
	YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_HIGHLIGHT3);
};

<i>/**
* Renders a single standard calendar cell using the CSS hightlight4 style
* @method renderCellStyleHighlight4
* @param {Date}					workingDate		The current working Date object being used to generate the calendar
* @param {HTMLTableCellElement}	cell			The current working cell <b>in</b> the calendar
*/</i>
YAHOO.widget.Calendar.prototype.renderCellStyleHighlight4 = <b>function</b>(workingDate, cell) {
	YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_HIGHLIGHT4);
};

<i>/**
* Applies the <b>default</b> style used <b>for</b> rendering today's date to the current calendar cell
* @method renderCellStyleToday
* @param {Date}					workingDate		The current working Date object being used to generate the calendar
* @param {HTMLTableCellElement}	cell			The current working cell <b>in</b> the calendar
*/</i>
YAHOO.widget.Calendar.prototype.renderCellStyleToday = <b>function</b>(workingDate, cell) {
	YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_TODAY);
};

<i>/**
* Applies the <b>default</b> style used <b>for</b> rendering selected dates to the current calendar cell
* @method renderCellStyleSelected
* @param {Date}					workingDate		The current working Date object being used to generate the calendar
* @param {HTMLTableCellElement}	cell			The current working cell <b>in</b> the calendar
* @<b>return</b> {String} YAHOO.widget.Calendar.STOP_RENDER <b>if</b> rendering should stop <b>with</b> this style, null or nothing <b>if</b> rendering
*			should not be terminated
*/</i>
YAHOO.widget.Calendar.prototype.renderCellStyleSelected = <b>function</b>(workingDate, cell) {
	YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_SELECTED);
};

<i>/**
* Applies the <b>default</b> style used <b>for</b> rendering dates that are not a part of the current
* month (preceding or trailing the cells <b>for</b> the current month)
* @method renderCellNotThisMonth
* @param {Date}					workingDate		The current working Date object being used to generate the calendar
* @param {HTMLTableCellElement}	cell			The current working cell <b>in</b> the calendar
* @<b>return</b> {String} YAHOO.widget.Calendar.STOP_RENDER <b>if</b> rendering should stop <b>with</b> this style, null or nothing <b>if</b> rendering
*			should not be terminated
*/</i>
YAHOO.widget.Calendar.prototype.renderCellNotThisMonth = <b>function</b>(workingDate, cell) {
	YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_OOM);
	cell.innerHTML=workingDate.getDate();
	<b>return</b> YAHOO.widget.Calendar.STOP_RENDER;
};

<i>/**
* Renders the current calendar cell as a non-selectable &quot;black-out&quot; date using the <b>default</b>
* restricted style.
* @method renderBodyCellRestricted
* @param {Date}					workingDate		The current working Date object being used to generate the calendar
* @param {HTMLTableCellElement}	cell			The current working cell <b>in</b> the calendar
* @<b>return</b> {String} YAHOO.widget.Calendar.STOP_RENDER <b>if</b> rendering should stop <b>with</b> this style, null or nothing <b>if</b> rendering
*			should not be terminated
*/</i>
YAHOO.widget.Calendar.prototype.renderBodyCellRestricted = <b>function</b>(workingDate, cell) {
	YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL);
	YAHOO.util.Dom.addClass(cell, <b>this</b>.Style.CSS_CELL_RESTRICTED);
	cell.innerHTML=workingDate.getDate();
	<b>return</b> YAHOO.widget.Calendar.STOP_RENDER;
};

<i>// END BUILT-IN TABLE CELL RENDERERS</i>

<i>// BEGIN MONTH NAVIGATION METHODS</i>

<i>/**
* Adds the designated number of months to the current calendar month, and sets the current
* calendar page date to the <b>new</b> month.
* @method addMonths
* @param {Number}	count	The number of months to add to the current calendar
*/</i>
YAHOO.widget.Calendar.prototype.addMonths = <b>function</b>(count) {
	<b>this</b>.cfg.setProperty(&quot;pagedate&quot;, YAHOO.widget.DateMath.add(<b>this</b>.cfg.getProperty(&quot;pagedate&quot;), YAHOO.widget.DateMath.MONTH, count));
	<b>this</b>.resetRenderers();
	<b>this</b>.changePageEvent.fire();
};

<i>/**
* Subtracts the designated number of months from the current calendar month, and sets the current
* calendar page date to the <b>new</b> month.
* @method subtractMonths
* @param {Number}	count	The number of months to subtract from the current calendar
*/</i>
YAHOO.widget.Calendar.prototype.subtractMonths = <b>function</b>(count) {
	<b>this</b>.cfg.setProperty(&quot;pagedate&quot;, YAHOO.widget.DateMath.subtract(<b>this</b>.cfg.getProperty(&quot;pagedate&quot;), YAHOO.widget.DateMath.MONTH, count));
	<b>this</b>.resetRenderers();
	<b>this</b>.changePageEvent.fire();
};

<i>/**
* Adds the designated number of years to the current calendar, and sets the current
* calendar page date to the <b>new</b> month.
* @method addYears
* @param {Number}	count	The number of years to add to the current calendar
*/</i>
YAHOO.widget.Calendar.prototype.addYears = <b>function</b>(count) {
	<b>this</b>.cfg.setProperty(&quot;pagedate&quot;, YAHOO.widget.DateMath.add(<b>this</b>.cfg.getProperty(&quot;pagedate&quot;), YAHOO.widget.DateMath.YEAR, count));
	<b>this</b>.resetRenderers();
	<b>this</b>.changePageEvent.fire();
};

<i>/**
* Subtcats the designated number of years from the current calendar, and sets the current
* calendar page date to the <b>new</b> month.
* @method subtractYears
* @param {Number}	count	The number of years to subtract from the current calendar
*/</i>
YAHOO.widget.Calendar.prototype.subtractYears = <b>function</b>(count) {
	<b>this</b>.cfg.setProperty(&quot;pagedate&quot;, YAHOO.widget.DateMath.subtract(<b>this</b>.cfg.getProperty(&quot;pagedate&quot;), YAHOO.widget.DateMath.YEAR, count));
	<b>this</b>.resetRenderers();
	<b>this</b>.changePageEvent.fire();
};

<i>/**
* Navigates to the next month page <b>in</b> the calendar widget.
* @method nextMonth
*/</i>
YAHOO.widget.Calendar.prototype.nextMonth = <b>function</b>() {
	<b>this</b>.addMonths(1);
};

<i>/**
* Navigates to the previous month page <b>in</b> the calendar widget.
* @method previousMonth
*/</i>
YAHOO.widget.Calendar.prototype.previousMonth = <b>function</b>() {
	<b>this</b>.subtractMonths(1);
};

<i>/**
* Navigates to the next year <b>in</b> the currently selected month <b>in</b> the calendar widget.
* @method nextYear
*/</i>
YAHOO.widget.Calendar.prototype.nextYear = <b>function</b>() {
	<b>this</b>.addYears(1);
};

<i>/**
* Navigates to the previous year <b>in</b> the currently selected month <b>in</b> the calendar widget.
* @method previousYear
*/</i>
YAHOO.widget.Calendar.prototype.previousYear = <b>function</b>() {
	<b>this</b>.subtractYears(1);
};

<i>// END MONTH NAVIGATION METHODS</i>

<i>// BEGIN SELECTION METHODS</i>

<i>/**
* Resets the calendar widget to the originally selected month and year, and
* sets the calendar to the initial selection(s).
* @method reset
*/</i>
YAHOO.widget.Calendar.prototype.reset = <b>function</b>() {
	<b>this</b>.cfg.resetProperty(&quot;selected&quot;);
	<b>this</b>.cfg.resetProperty(&quot;pagedate&quot;);
	<b>this</b>.resetEvent.fire();
};

<i>/**
* Clears the selected dates <b>in</b> the current calendar widget and sets the calendar
* to the current month and year.
* @method clear
*/</i>
YAHOO.widget.Calendar.prototype.clear = <b>function</b>() {
	<b>this</b>.cfg.setProperty(&quot;selected&quot;, []);
	<b>this</b>.cfg.setProperty(&quot;pagedate&quot;, <b>new</b> Date(<b>this</b>.today.getTime()));
	<b>this</b>.clearEvent.fire();
};

<i>/**
* Selects a date or a collection of dates on the current calendar. This method, by <b>default</b>,
* does not call the render method explicitly. Once selection has completed, render must be
* called <b>for</b> the changes to be reflected visually.
* @method select
* @param	{String/Date/Date[]}	date	The date string of dates to select <b>in</b> the current calendar. Valid formats are
*								individual date(s) (12/24/2005,12/26/2005) or date range(s) (12/24/2005-1/1/2006).
*								Multiple comma-delimited dates can also be passed to <b>this</b> method (12/24/2005,12/11/2005-12/13/2005).
*								This method can also take a JavaScript Date object or an array of Date objects.
* @<b>return</b>	{Date[]}			Array of JavaScript Date objects representing all individual dates that are currently selected.
*/</i>
YAHOO.widget.Calendar.prototype.select = <b>function</b>(date) {
	<b>this</b>.beforeSelectEvent.fire();

	<b>var</b> selected = <b>this</b>.cfg.getProperty(&quot;selected&quot;);
	<b>var</b> aToBeSelected = <b>this</b>._toFieldArray(date);

	<b>for</b> (<b>var</b> a=0;a&lt;aToBeSelected.length;++a) {
		<b>var</b> toSelect = aToBeSelected[a]; <i>// For each date item <b>in</b> the list of dates we're trying to select</i>
		<b>if</b> (<b>this</b>._indexOfSelectedFieldArray(toSelect) == -1) { <i>// not already selected?</i>
			selected[selected.length]=toSelect;
		}
	}

	<b>if</b> (<b>this</b>.parent) {
		<b>this</b>.parent.cfg.setProperty(&quot;selected&quot;, selected);
	} <b>else</b> {
		<b>this</b>.cfg.setProperty(&quot;selected&quot;, selected);
	}

	<b>this</b>.selectEvent.fire(aToBeSelected);

	<b>return</b> this.getSelectedDates();
};

<i>/**
* Selects a date on the current calendar by referencing the index of the cell that should be selected.
* This method is used to easily select a single cell (usually <b>with</b> a mouse click) without having to <b>do</b>
* a full render. The selected style is applied to the cell directly.
* @method selectCell
* @param	{Number}	cellIndex	The index of the cell to select <b>in</b> the current calendar.
* @<b>return</b>	{Date[]}	Array of JavaScript Date objects representing all individual dates that are currently selected.
*/</i>
YAHOO.widget.Calendar.prototype.selectCell = <b>function</b>(cellIndex) {
	<b>this</b>.beforeSelectEvent.fire();

	<b>var</b> selected = <b>this</b>.cfg.getProperty(&quot;selected&quot;);

	<b>var</b> cell = <b>this</b>.cells[cellIndex];
	<b>var</b> cellDate = <b>this</b>.cellDates[cellIndex];

	<b>var</b> dCellDate = <b>this</b>._toDate(cellDate);

	<b>var</b> selectDate = cellDate.concat();

	selected[selected.length] = selectDate;

	<b>if</b> (<b>this</b>.parent) {
		<b>this</b>.parent.cfg.setProperty(&quot;selected&quot;, selected);
	} <b>else</b> {
		<b>this</b>.cfg.setProperty(&quot;selected&quot;, selected);
	}

	<b>this</b>.renderCellStyleSelected(dCellDate,cell);

	<b>this</b>.selectEvent.fire([selectDate]);

	<b>this</b>.doCellMouseOut.call(cell, null, <b>this</b>);

	<b>return</b> this.getSelectedDates();
};

<i>/**
* Deselects a date or a collection of dates on the current calendar. This method, by <b>default</b>,
* does not call the render method explicitly. Once deselection has completed, render must be
* called <b>for</b> the changes to be reflected visually.
* @method deselect
* @param	{String/Date/Date[]}	date	The date string of dates to deselect <b>in</b> the current calendar. Valid formats are
*								individual date(s) (12/24/2005,12/26/2005) or date range(s) (12/24/2005-1/1/2006).
*								Multiple comma-delimited dates can also be passed to <b>this</b> method (12/24/2005,12/11/2005-12/13/2005).
*								This method can also take a JavaScript Date object or an array of Date objects.
* @<b>return</b>	{Date[]}			Array of JavaScript Date objects representing all individual dates that are currently selected.
*/</i>
YAHOO.widget.Calendar.prototype.deselect = <b>function</b>(date) {
	<b>this</b>.beforeDeselectEvent.fire();

	<b>var</b> selected = <b>this</b>.cfg.getProperty(&quot;selected&quot;);

	<b>var</b> aToBeSelected = <b>this</b>._toFieldArray(date);

	<b>for</b> (<b>var</b> a=0;a&lt;aToBeSelected.length;++a) {
		<b>var</b> toSelect = aToBeSelected[a]; <i>// For each date item <b>in</b> the list of dates we're trying to select</i>
		<b>var</b> index = <b>this</b>._indexOfSelectedFieldArray(toSelect);

		<b>if</b> (index != -1) {
			selected.splice(index,1);
		}
	}

	<b>if</b> (<b>this</b>.parent) {
		<b>this</b>.parent.cfg.setProperty(&quot;selected&quot;, selected);
	} <b>else</b> {
		<b>this</b>.cfg.setProperty(&quot;selected&quot;, selected);
	}

	<b>this</b>.deselectEvent.fire(aToBeSelected);

	<b>return</b> this.getSelectedDates();
};

<i>/**
* Deselects a date on the current calendar by referencing the index of the cell that should be deselected.
* This method is used to easily deselect a single cell (usually <b>with</b> a mouse click) without having to <b>do</b>
* a full render. The selected style is removed from the cell directly.
* @method deselectCell
* @param	{Number}	cellIndex	The index of the cell to deselect <b>in</b> the current calendar.
* @<b>return</b>	{Date[]}	Array of JavaScript Date objects representing all individual dates that are currently selected.
*/</i>
YAHOO.widget.Calendar.prototype.deselectCell = <b>function</b>(i) {
	<b>this</b>.beforeDeselectEvent.fire();

	<b>var</b> selected = <b>this</b>.cfg.getProperty(&quot;selected&quot;);

	<b>var</b> cell = <b>this</b>.cells[i];
	<b>var</b> cellDate = <b>this</b>.cellDates[i];
	<b>var</b> cellDateIndex = <b>this</b>._indexOfSelectedFieldArray(cellDate);

	<b>var</b> dCellDate = <b>this</b>._toDate(cellDate);

	<b>var</b> selectDate = cellDate.concat();

	<b>if</b> (cellDateIndex &gt; -1) {
		<b>if</b> (<b>this</b>.cfg.getProperty(&quot;pagedate&quot;).getMonth() == dCellDate.getMonth() &amp;&amp;
			<b>this</b>.cfg.getProperty(&quot;pagedate&quot;).getFullYear() == dCellDate.getFullYear()) {
			YAHOO.util.Dom.removeClass(cell, <b>this</b>.Style.CSS_CELL_SELECTED);
		}

		selected.splice(cellDateIndex, 1);
	}


	<b>if</b> (<b>this</b>.parent) {
		<b>this</b>.parent.cfg.setProperty(&quot;selected&quot;, selected);
	} <b>else</b> {
		<b>this</b>.cfg.setProperty(&quot;selected&quot;, selected);
	}

	<b>this</b>.deselectEvent.fire(selectDate);
	<b>return</b> this.getSelectedDates();
};

<i>/**
* Deselects all dates on the current calendar.
* @method deselectAll
* @<b>return</b> {Date[]}		Array of JavaScript Date objects representing all individual dates that are currently selected.
*						Assuming that <b>this</b> function executes properly, the <b>return</b> value should be an empty array.
*						However, the empty array is returned <b>for</b> the sake of being able to check the selection status
*						of the calendar.
*/</i>
YAHOO.widget.Calendar.prototype.deselectAll = <b>function</b>() {
	<b>this</b>.beforeDeselectEvent.fire();

	<b>var</b> selected = <b>this</b>.cfg.getProperty(&quot;selected&quot;);
	<b>var</b> count = selected.length;
	<b>var</b> sel = selected.concat();

	<b>if</b> (<b>this</b>.parent) {
		<b>this</b>.parent.cfg.setProperty(&quot;selected&quot;, []);
	} <b>else</b> {
		<b>this</b>.cfg.setProperty(&quot;selected&quot;, []);
	}

	<b>if</b> (count &gt; 0) {
		<b>this</b>.deselectEvent.fire(sel);
	}

	<b>return</b> this.getSelectedDates();
};

<i>// END SELECTION METHODS</i>

<i>// BEGIN TYPE CONVERSION METHODS</i>

<i>/**
* Converts a date (either a JavaScript Date object, or a date string) to the internal data structure
* used to represent dates: [[yyyy,mm,dd],[yyyy,mm,dd]].
* @method _toFieldArray
* @private
* @param	{String/Date/Date[]}	date	The date string of dates to deselect <b>in</b> the current calendar. Valid formats are
*								individual date(s) (12/24/2005,12/26/2005) or date range(s) (12/24/2005-1/1/2006).
*								Multiple comma-delimited dates can also be passed to <b>this</b> method (12/24/2005,12/11/2005-12/13/2005).
*								This method can also take a JavaScript Date object or an array of Date objects.
* @<b>return</b> {Array[](Number[])}	Array of date field arrays
*/</i>
YAHOO.widget.Calendar.prototype._toFieldArray = <b>function</b>(date) {
	<b>var</b> returnDate = [];

	<b>if</b> (date instanceof Date) {
		returnDate = [[date.getFullYear(), date.getMonth()+1, date.getDate()]];
	} <b>else</b> if (<b>typeof</b> date == 'string') {
		returnDate = <b>this</b>._parseDates(date);
	} <b>else</b> if (date instanceof Array) {
		<b>for</b> (<b>var</b> i=0;i&lt;date.length;++i) {
			<b>var</b> d = date[i];
			returnDate[returnDate.length] = [d.getFullYear(),d.getMonth()+1,d.getDate()];
		}
	}

	<b>return</b> returnDate;
};

<i>/**
* Converts a date field array [yyyy,mm,dd] to a JavaScript Date object.
* @method _toDate
* @private
* @param	{Number[]}		dateFieldArray	The date field array to convert to a JavaScript Date.
* @<b>return</b>	{Date}	JavaScript Date object representing the date field array
*/</i>
YAHOO.widget.Calendar.prototype._toDate = <b>function</b>(dateFieldArray) {
	<b>if</b> (dateFieldArray instanceof Date) {
		<b>return</b> dateFieldArray;
	} <b>else</b> {
		<b>return</b> new Date(dateFieldArray[0],dateFieldArray[1]-1,dateFieldArray[2]);
	}
};

<i>// END TYPE CONVERSION METHODS</i>

<i>// BEGIN UTILITY METHODS</i>

<i>/**
* Converts a date field array [yyyy,mm,dd] to a JavaScript Date object.
* @method _fieldArraysAreEqual
* @private
* @param	{Number[]}	array1	The first date field array to compare
* @param	{Number[]}	array2	The first date field array to compare
* @<b>return</b>	{Boolean}	The boolean that represents the equality of the two arrays
*/</i>
YAHOO.widget.Calendar.prototype._fieldArraysAreEqual = <b>function</b>(array1, array2) {
	<b>var</b> match = false;

	<b>if</b> (array1[0]==array2[0]&amp;&amp;array1[1]==array2[1]&amp;&amp;array1[2]==array2[2]) {
		match=true;
	}

	<b>return</b> match;
};

<i>/**
* Gets the index of a date field array [yyyy,mm,dd] <b>in</b> the current list of selected dates.
* @method	_indexOfSelectedFieldArray
* @private
* @param	{Number[]}		find	The date field array to search <b>for</b>
* @<b>return</b>	{Number}			The index of the date field array within the collection of selected dates.
*								-1 will be returned <b>if</b> the date is not found.
*/</i>
YAHOO.widget.Calendar.prototype._indexOfSelectedFieldArray = <b>function</b>(find) {
	<b>var</b> selected = -1;
	<b>var</b> seldates = <b>this</b>.cfg.getProperty(&quot;selected&quot;);

	<b>for</b> (<b>var</b> s=0;s&lt;seldates.length;++s) {
		<b>var</b> sArray = seldates[s];
		<b>if</b> (find[0]==sArray[0]&amp;&amp;find[1]==sArray[1]&amp;&amp;find[2]==sArray[2]) {
			selected = s;
			<b>break</b>;
		}
	}

	<b>return</b> selected;
};

<i>/**
* Determines whether a given date is OOM (out of month).
* @method	isDateOOM
* @param	{Date}	date	The JavaScript Date object <b>for</b> which to check the OOM status
* @<b>return</b>	{Boolean}	true <b>if</b> the date is OOM
*/</i>
YAHOO.widget.Calendar.prototype.isDateOOM = <b>function</b>(date) {
	<b>var</b> isOOM = false;
	<b>if</b> (date.getMonth() != <b>this</b>.cfg.getProperty(&quot;pagedate&quot;).getMonth()) {
		isOOM = true;
	}
	<b>return</b> isOOM;
};

<i>// END UTILITY METHODS</i>

<i>// BEGIN EVENT HANDLERS</i>

<i>/**
* Event executed before a date is selected <b>in</b> the calendar widget.
* @deprecated Event handlers <b>for</b> this event should be susbcribed to beforeSelectEvent.
*/</i>
YAHOO.widget.Calendar.prototype.onBeforeSelect = <b>function</b>() {
	<b>if</b> (<b>this</b>.cfg.getProperty(&quot;MULTI_SELECT&quot;) === false) {
		<b>if</b> (<b>this</b>.parent) {
			<b>this</b>.parent.callChildFunction(&quot;clearAllBodyCellStyles&quot;, <b>this</b>.Style.CSS_CELL_SELECTED);
			<b>this</b>.parent.deselectAll();
		} <b>else</b> {
			<b>this</b>.clearAllBodyCellStyles(<b>this</b>.Style.CSS_CELL_SELECTED);
			<b>this</b>.deselectAll();
		}
	}
};

<i>/**
* Event executed when a date is selected <b>in</b> the calendar widget.
* @param	{Array}	selected	An array of date field arrays representing which date or dates were selected. Example: [ [2006,8,6],[2006,8,7],[2006,8,8] ]
* @deprecated Event handlers <b>for</b> this event should be susbcribed to selectEvent.
*/</i>
YAHOO.widget.Calendar.prototype.onSelect = <b>function</b>(selected) { };

<i>/**
* Event executed before a date is deselected <b>in</b> the calendar widget.
* @deprecated Event handlers <b>for</b> this event should be susbcribed to beforeDeselectEvent.
*/</i>
YAHOO.widget.Calendar.prototype.onBeforeDeselect = <b>function</b>() { };

<i>/**
* Event executed when a date is deselected <b>in</b> the calendar widget.
* @param	{Array}	selected	An array of date field arrays representing which date or dates were deselected. Example: [ [2006,8,6],[2006,8,7],[2006,8,8] ]
* @deprecated Event handlers <b>for</b> this event should be susbcribed to deselectEvent.
*/</i>
YAHOO.widget.Calendar.prototype.onDeselect = <b>function</b>(deselected) { };

<i>/**
* Event executed when the user navigates to a different calendar page.
* @deprecated Event handlers <b>for</b> this event should be susbcribed to changePageEvent.
*/</i>
YAHOO.widget.Calendar.prototype.onChangePage = <b>function</b>() {
	<b>this</b>.render();
};

<i>/**
* Event executed when the calendar widget is rendered.
* @deprecated Event handlers <b>for</b> this event should be susbcribed to renderEvent.
*/</i>
YAHOO.widget.Calendar.prototype.onRender = <b>function</b>() { };

<i>/**
* Event executed when the calendar widget is reset to its original state.
* @deprecated Event handlers <b>for</b> this event should be susbcribed to resetEvemt.
*/</i>
YAHOO.widget.Calendar.prototype.onReset = <b>function</b>() { <b>this</b>.render(); };

<i>/**
* Event executed when the calendar widget is completely cleared to the current month <b>with</b> no selections.
* @deprecated Event handlers <b>for</b> this event should be susbcribed to clearEvent.
*/</i>
YAHOO.widget.Calendar.prototype.onClear = <b>function</b>() { <b>this</b>.render(); };

<i>/**
* Validates the calendar widget. This method has no <b>default</b> implementation
* and must be extended by subclassing the widget.
* @<b>return</b>	Should <b>return</b> true <b>if</b> the widget validates, and false <b>if</b>
* it doesn't.
* @type Boolean
*/</i>
YAHOO.widget.Calendar.prototype.validate = <b>function</b>() { <b>return</b> true; };

<i>// END EVENT HANDLERS</i>

<i>// BEGIN DATE PARSE METHODS</i>

<i>/**
* Converts a date string to a date field array
* @private
* @param	{String}	sDate			Date string. Valid formats are mm/dd and mm/dd/yyyy.
* @<b>return</b>				A date field array representing the string passed to the method
* @type Array[](Number[])
*/</i>
YAHOO.widget.Calendar.prototype._parseDate = <b>function</b>(sDate) {
	<b>var</b> aDate = sDate.split(<b>this</b>.Locale.DATE_FIELD_DELIMITER);
	<b>var</b> rArray;

	<b>if</b> (aDate.length == 2) {
		rArray = [aDate[<b>this</b>.Locale.MD_MONTH_POSITION-1],aDate[<b>this</b>.Locale.MD_DAY_POSITION-1]];
		rArray.type = YAHOO.widget.Calendar.MONTH_DAY;
	} <b>else</b> {
		rArray = [aDate[<b>this</b>.Locale.MDY_YEAR_POSITION-1],aDate[<b>this</b>.Locale.MDY_MONTH_POSITION-1],aDate[<b>this</b>.Locale.MDY_DAY_POSITION-1]];
		rArray.type = YAHOO.widget.Calendar.DATE;
	}

	<b>for</b> (<b>var</b> i=0;i&lt;rArray.length;i++) {
		rArray[i] = parseInt(rArray[i], 10);
	}

	<b>return</b> rArray;
};

<i>/**
* Converts a multi or single-date string to an array of date field arrays
* @private
* @param	{String}	sDates		Date string <b>with</b> one or more comma-delimited dates. Valid formats are mm/dd, mm/dd/yyyy, mm/dd/yyyy-mm/dd/yyyy
* @<b>return</b>							An array of date field arrays
* @type Array[](Number[])
*/</i>
YAHOO.widget.Calendar.prototype._parseDates = <b>function</b>(sDates) {
	<b>var</b> aReturn = [];

	<b>var</b> aDates = sDates.split(<b>this</b>.Locale.DATE_DELIMITER);

	<b>for</b> (<b>var</b> d=0;d&lt;aDates.length;++d) {
		<b>var</b> sDate = aDates[d];

		<b>if</b> (sDate.indexOf(<b>this</b>.Locale.DATE_RANGE_DELIMITER) != -1) {
			<i>// This is a range</i>
			<b>var</b> aRange = sDate.split(<b>this</b>.Locale.DATE_RANGE_DELIMITER);

			<b>var</b> dateStart = <b>this</b>._parseDate(aRange[0]);
			<b>var</b> dateEnd = <b>this</b>._parseDate(aRange[1]);

			<b>var</b> fullRange = <b>this</b>._parseRange(dateStart, dateEnd);
			aReturn = aReturn.concat(fullRange);
		} <b>else</b> {
			<i>// This is not a range</i>
			<b>var</b> aDate = <b>this</b>._parseDate(sDate);
			aReturn.push(aDate);
		}
	}
	<b>return</b> aReturn;
};

<i>/**
* Converts a date range to the full list of included dates
* @private
* @param	{Number[]}	startDate	Date field array representing the first date <b>in</b> the range
* @param	{Number[]}	endDate		Date field array representing the last date <b>in</b> the range
* @<b>return</b>							An array of date field arrays
* @type Array[](Number[])
*/</i>
YAHOO.widget.Calendar.prototype._parseRange = <b>function</b>(startDate, endDate) {
	<b>var</b> dStart   = <b>new</b> Date(startDate[0],startDate[1]-1,startDate[2]);
	<b>var</b> dCurrent = YAHOO.widget.DateMath.add(<b>new</b> Date(startDate[0],startDate[1]-1,startDate[2]),YAHOO.widget.DateMath.DAY,1);
	<b>var</b> dEnd     = <b>new</b> Date(endDate[0],  endDate[1]-1,  endDate[2]);

	<b>var</b> results = [];
	results.push(startDate);
	<b>while</b> (dCurrent.getTime() &lt;= dEnd.getTime()) {
		results.push([dCurrent.getFullYear(),dCurrent.getMonth()+1,dCurrent.getDate()]);
		dCurrent = YAHOO.widget.DateMath.add(dCurrent,YAHOO.widget.DateMath.DAY,1);
	}
	<b>return</b> results;
};

<i>// END DATE PARSE METHODS</i>

<i>// BEGIN RENDERER METHODS</i>

<i>/**
* Resets the render stack of the current calendar to its original pre-render value.
*/</i>
YAHOO.widget.Calendar.prototype.resetRenderers = <b>function</b>() {
	<b>this</b>.renderStack = <b>this</b>._renderStack.concat();
};

<i>/**
* Clears the inner HTML, CSS class and style information from the specified cell.
* @method clearElement
* @param	{HTMLTableCellElement}	The cell to clear
*/</i>
YAHOO.widget.Calendar.prototype.clearElement = <b>function</b>(cell) {
	cell.innerHTML = &quot;&amp;#160;&quot;;
	cell.className=&quot;&quot;;
};

<i>/**
* Adds a renderer to the render stack. The <b>function</b> reference passed to <b>this</b> method will be executed
* when a date cell matches the conditions specified <b>in</b> the date string <b>for</b> this renderer.
* @method addRenderer
* @param	{String}	sDates		A date string to associate <b>with</b> the specified renderer. Valid formats
*									include date (12/24/2005), month/day (12/24), and range (12/1/2004-1/1/2005)
* @param	{Function}	fnRender	The <b>function</b> executed to render cells that match the render rules <b>for</b> this renderer.
*/</i>
YAHOO.widget.Calendar.prototype.addRenderer = <b>function</b>(sDates, fnRender) {
	<b>var</b> aDates = <b>this</b>._parseDates(sDates);
	<b>for</b> (<b>var</b> i=0;i&lt;aDates.length;++i) {
		<b>var</b> aDate = aDates[i];

		<b>if</b> (aDate.length == 2) { <i>// <b>this</b> is either a range or a month/day combo</i>
			<b>if</b> (aDate[0] instanceof Array) { <i>// <b>this</b> is a range</i>
				<b>this</b>._addRenderer(YAHOO.widget.Calendar.RANGE,aDate,fnRender);
			} <b>else</b> { <i>// <b>this</b> is a month/day combo</i>
				<b>this</b>._addRenderer(YAHOO.widget.Calendar.MONTH_DAY,aDate,fnRender);
			}
		} <b>else</b> if (aDate.length == 3) {
			<b>this</b>._addRenderer(YAHOO.widget.Calendar.DATE,aDate,fnRender);
		}
	}
};

<i>/**
* The private method used <b>for</b> adding cell renderers to the local render stack.
* This method is called by other methods that set the renderer type prior to the method call.
* @method _addRenderer
* @private
* @param	{String}	type		The type string that indicates the type of date renderer being added.
*									Values are YAHOO.widget.Calendar.DATE, YAHOO.widget.Calendar.MONTH_DAY, YAHOO.widget.Calendar.WEEKDAY,
*									YAHOO.widget.Calendar.RANGE, YAHOO.widget.Calendar.MONTH
* @param	{Array}		aDates		An array of dates used to construct the renderer. The format varies based
*									on the renderer type
* @param	{Function}	fnRender	The <b>function</b> executed to render cells that match the render rules <b>for</b> this renderer.
*/</i>
YAHOO.widget.Calendar.prototype._addRenderer = <b>function</b>(type, aDates, fnRender) {
	<b>var</b> add = [type,aDates,fnRender];
	<b>this</b>.renderStack.unshift(add);
	<b>this</b>._renderStack = <b>this</b>.renderStack.concat();
};

<i>/**
* Adds a month to the render stack. The <b>function</b> reference passed to <b>this</b> method will be executed
* when a date cell matches the month passed to <b>this</b> method.
* @method addMonthRenderer
* @param	{Number}	month		The month (1-12) to associate <b>with</b> this renderer
* @param	{Function}	fnRender	The <b>function</b> executed to render cells that match the render rules <b>for</b> this renderer.
*/</i>
YAHOO.widget.Calendar.prototype.addMonthRenderer = <b>function</b>(month, fnRender) {
	<b>this</b>._addRenderer(YAHOO.widget.Calendar.MONTH,[month],fnRender);
};

<i>/**
* Adds a weekday to the render stack. The <b>function</b> reference passed to <b>this</b> method will be executed
* when a date cell matches the weekday passed to <b>this</b> method.
* @method addWeekdayRenderer
* @param	{Number}	weekday		The weekday (0-6) to associate <b>with</b> this renderer
* @param	{Function}	fnRender	The <b>function</b> executed to render cells that match the render rules <b>for</b> this renderer.
*/</i>
YAHOO.widget.Calendar.prototype.addWeekdayRenderer = <b>function</b>(weekday, fnRender) {
	<b>this</b>._addRenderer(YAHOO.widget.Calendar.WEEKDAY,[weekday],fnRender);
};

<i>// END RENDERER METHODS</i>

<i>// BEGIN CSS METHODS</i>

<i>/**
* Removes all styles from all body cells <b>in</b> the current calendar table.
* @method clearAllBodyCellStyles
* @param	{style}		The CSS class name to remove from all calendar body cells
*/</i>
YAHOO.widget.Calendar.prototype.clearAllBodyCellStyles = <b>function</b>(style) {
	<b>for</b> (<b>var</b> c=0;c&lt;<b>this</b>.cells.length;++c) {
		YAHOO.util.Dom.removeClass(<b>this</b>.cells[c],style);
	}
};

<i>// END CSS METHODS</i>

<i>// BEGIN GETTER/SETTER METHODS</i>
<i>/**
* Sets the calendar's month explicitly
* @method setMonth
* @param {Number}	month		The numeric month, from 0 (January) to 11 (December)
*/</i>
YAHOO.widget.Calendar.prototype.setMonth = <b>function</b>(month) {
	<b>var</b> current = <b>this</b>.cfg.getProperty(&quot;pagedate&quot;);
	current.setMonth(month);
	<b>this</b>.cfg.setProperty(&quot;pagedate&quot;, current);
};

<i>/**
* Sets the calendar's year explicitly.
* @method setYear
* @param {Number}	year		The numeric 4-digit year
*/</i>
YAHOO.widget.Calendar.prototype.setYear = <b>function</b>(year) {
	<b>var</b> current = <b>this</b>.cfg.getProperty(&quot;pagedate&quot;);
	current.setFullYear(year);
	<b>this</b>.cfg.setProperty(&quot;pagedate&quot;, current);
};

<i>/**
* Gets the list of currently selected dates from the calendar.
* @method getSelectedDates
* @<b>return</b> {Date[]} An array of currently selected JavaScript Date objects.
*/</i>
YAHOO.widget.Calendar.prototype.getSelectedDates = <b>function</b>() {
	<b>var</b> returnDates = [];
	<b>var</b> selected = <b>this</b>.cfg.getProperty(&quot;selected&quot;);

	<b>for</b> (<b>var</b> d=0;d&lt;selected.length;++d) {
		<b>var</b> dateArray = selected[d];

		<b>var</b> date = <b>new</b> Date(dateArray[0],dateArray[1]-1,dateArray[2]);
		returnDates.push(date);
	}

	returnDates.sort( <b>function</b>(a,b) { <b>return</b> a-b; } );
	<b>return</b> returnDates;
};

<i>/// END GETTER/SETTER METHODS ///</i>

<i>/**
* Hides the Calendar's outer container from view.
* @method hide
*/</i>
YAHOO.widget.Calendar.prototype.hide = <b>function</b>() {
	<b>this</b>.oDomContainer.style.display = &quot;none&quot;;
};

<i>/**
* Shows the Calendar's outer container.
* @method show
*/</i>
YAHOO.widget.Calendar.prototype.show = <b>function</b>() {
	<b>this</b>.oDomContainer.style.display = &quot;block&quot;;
};

<i>/**
* Returns a string representing the current browser.
* @property browser
* @type String
*/</i>
YAHOO.widget.Calendar.prototype.browser = <b>function</b>() {
			<b>var</b> ua = navigator.userAgent.toLowerCase();
				  <b>if</b> (ua.indexOf('opera')!=-1) { <i>// Opera (check first <b>in</b> case of spoof)</i>
					 <b>return</b> 'opera';
				  } <b>else</b> if (ua.indexOf('msie 7')!=-1) { <i>// IE7</i>
					 <b>return</b> 'ie7';
				  } <b>else</b> if (ua.indexOf('msie') !=-1) { <i>// IE</i>
					 <b>return</b> 'ie';
				  } <b>else</b> if (ua.indexOf('safari')!=-1) { <i>// Safari (check before Gecko because it includes &quot;like Gecko&quot;)</i>
					 <b>return</b> 'safari';
				  } <b>else</b> if (ua.indexOf('gecko') != -1) { <i>// Gecko</i>
					 <b>return</b> 'gecko';
				  } <b>else</b> {
					 <b>return</b> false;
				  }
			}();
<i>/**
* Returns a string representation of the object.
* @method toString
* @<b>return</b> {String}	A string representation of the Calendar object.
*/</i>
YAHOO.widget.Calendar.prototype.toString = <b>function</b>() {
	<b>return</b> &quot;Calendar &quot; + <b>this</b>.id;
};

<i>/**
* @namespace YAHOO.widget
* @class Calendar_Core
* @extends YAHOO.widget.Calendar
* @deprecated The old Calendar_Core class is no longer necessary.
*/</i>
YAHOO.widget.Calendar_Core = YAHOO.widget.Calendar;

YAHOO.widget.Cal_Core = YAHOO.widget.Calendar;

<i>/**
* YAHOO.widget.CalendarGroup is a special container class <b>for</b> YAHOO.widget.Calendar. This class facilitates
* the ability to have multi-page calendar views that share a single dataset and are
* dependent on each other.
*
* The calendar group instance will refer to each of its elements using a 0-based index.
* For example, to construct the placeholder <b>for</b> a calendar group widget <b>with</b> id &quot;cal1&quot; and
* containerId of &quot;cal1Container&quot;, the markup would be as follows:
*	&lt;xmp&gt;
*		&lt;div id=&quot;cal1Container_0&quot;&gt;&lt;/div&gt;
*		&lt;div id=&quot;cal1Container_1&quot;&gt;&lt;/div&gt;
*	&lt;/xmp&gt;
* The tables <b>for</b> the calendars (&quot;cal1_0&quot; and &quot;cal1_1&quot;) will be inserted into those containers.
* @namespace YAHOO.widget
* @class CalendarGroup
* @constructor
* @param {String}	id			The id of the table element that will represent the calendar widget
* @param {String}	containerId	The id of the container div element that will wrap the calendar table
* @param {Object}	config		The configuration object containing the Calendar's arguments
*/</i>
YAHOO.widget.CalendarGroup = <b>function</b>(id, containerId, config) {
	<b>if</b> (arguments.length &gt; 0) {
		<b>this</b>.init(id, containerId, config);
	}
};

<i>/**
* Initializes the calendar group. All subclasses must call <b>this</b> method <b>in</b> order <b>for</b> the
* group to be initialized properly.
* @method init
* @param {String}	id			The id of the table element that will represent the calendar widget
* @param {String}	containerId	The id of the container div element that will wrap the calendar table
* @param {Object}	config		The configuration object containing the Calendar's arguments
*/</i>
YAHOO.widget.CalendarGroup.prototype.init = <b>function</b>(id, containerId, config) {
	<b>this</b>.initEvents();
	<b>this</b>.initStyles();

	<i>/**
	* The collection of Calendar pages contained within the CalendarGroup
	* @property pages
	* @type YAHOO.widget.Calendar[]
	*/</i>
	<b>this</b>.pages = [];

	<i>/**
	* The unique id associated <b>with</b> the CalendarGroup
	* @property id
	* @type String
	*/</i>
	<b>this</b>.id = id;

	<i>/**
	* The unique id associated <b>with</b> the CalendarGroup container
	* @property containerId
	* @type String
	*/</i>
	<b>this</b>.containerId = containerId;

	<i>/**
	* The outer containing element <b>for</b> the CalendarGroup
	* @property oDomContainer
	* @type HTMLElement
	*/</i>
	<b>this</b>.oDomContainer = document.getElementById(containerId);

	YAHOO.util.Dom.addClass(<b>this</b>.oDomContainer, YAHOO.widget.CalendarGroup.CSS_CONTAINER);
	YAHOO.util.Dom.addClass(<b>this</b>.oDomContainer, YAHOO.widget.CalendarGroup.CSS_MULTI_UP);

	<i>/**
	* The Config object used to hold the configuration variables <b>for</b> the CalendarGroup
	* @property cfg
	* @type YAHOO.util.Config
	*/</i>
	<b>this</b>.cfg = <b>new</b> YAHOO.util.Config(<b>this</b>);

	<i>/**
	* The local object which contains the CalendarGroup's options
	* @property Options
	* @type Object
	*/</i>
	<b>this</b>.Options = {};

	<i>/**
	* The local object which contains the CalendarGroup's locale settings
	* @property Locale
	* @type Object
	*/</i>
	<b>this</b>.Locale = {};

	<b>this</b>.setupConfig();

	<b>if</b> (config) {
		<b>this</b>.cfg.applyConfig(config, true);
	}

	<b>this</b>.cfg.fireQueue();

	<i>// OPERA HACK FOR MISWRAPPED FLOATS</i>
	<b>if</b> (<b>this</b>.browser == &quot;opera&quot;){
		<b>var</b> fixWidth = <b>function</b>() {
			<b>var</b> startW = <b>this</b>.oDomContainer.offsetWidth;
			<b>var</b> w = 0;
			<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
				<b>var</b> cal = <b>this</b>.pages[p];
				w += cal.oDomContainer.offsetWidth;
			}
			<b>if</b> (w &gt; 0) {
				<b>this</b>.oDomContainer.style.width = w + &quot;px&quot;;
			}
		};
		<b>this</b>.renderEvent.subscribe(fixWidth,<b>this</b>,true);
	}
};


YAHOO.widget.CalendarGroup.prototype.setupConfig = <b>function</b>() {
	<i>/**
	* The number of pages to include <b>in</b> the CalendarGroup. This value can only be set once, <b>in</b> the CalendarGroup's constructor arguments.
	* @config pages
	* @type Number
	* @<b>default</b> 2
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;pages&quot;, { value:2, validator:<b>this</b>.cfg.checkNumber, handler:<b>this</b>.configPages } );

	<i>/**
	* The month/year representing the current visible Calendar date (mm/yyyy)
	* @config pagedate
	* @type String
	* @<b>default</b> today's date
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;pagedate&quot;, { value:<b>new</b> Date(), handler:<b>this</b>.configPageDate } );

	<i>/**
	* The date or range of dates representing the current Calendar selection
	* @config selected
	* @type String
	* @<b>default</b> []
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;selected&quot;, { value:[], handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The title to display above the CalendarGroup's month header
	* @config title
	* @type String
	* @<b>default</b> &quot;&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;title&quot;, { value:&quot;&quot;, handler:<b>this</b>.configTitle } );

	<i>/**
	* Whether or not a close button should be displayed <b>for</b> this CalendarGroup
	* @config close
	* @type Boolean
	* @<b>default</b> false
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;close&quot;, { value:false, handler:<b>this</b>.configClose } );

	<i>/**
	* Whether or not an iframe shim should be placed under the Calendar to prevent select boxes from bleeding through <b>in</b> Internet Explorer 6 and below.
	* @config iframe
	* @type Boolean
	* @<b>default</b> true
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;iframe&quot;, { value:true, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkBoolean } );

	<i>/**
	* The minimum selectable date <b>in</b> the current Calendar (mm/dd/yyyy)
	* @config mindate
	* @type String
	* @<b>default</b> null
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;mindate&quot;, { value:null, handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The maximum selectable date <b>in</b> the current Calendar (mm/dd/yyyy)
	* @config maxdate
	* @type String
	* @<b>default</b> null
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;maxdate&quot;, { value:null, handler:<b>this</b>.delegateConfig  } );

	<i>// Options properties</i>

	<i>/**
	* True <b>if</b> the Calendar should allow multiple selections. False by <b>default</b>.
	* @config MULTI_SELECT
	* @type Boolean
	* @<b>default</b> false
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MULTI_SELECT&quot;,	{ value:false, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkBoolean } );

	<i>/**
	* The weekday the week begins on. Default is 0 (Sunday).
	* @config START_WEEKDAY
	* @type number
	* @<b>default</b> 0
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;START_WEEKDAY&quot;,	{ value:0, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkNumber  } );

	<i>/**
	* True <b>if</b> the Calendar should show weekday labels. True by <b>default</b>.
	* @config SHOW_WEEKDAYS
	* @type Boolean
	* @<b>default</b> true
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;SHOW_WEEKDAYS&quot;,	{ value:true, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkBoolean } );

	<i>/**
	* True <b>if</b> the Calendar should show week row headers. False by <b>default</b>.
	* @config SHOW_WEEK_HEADER
	* @type Boolean
	* @<b>default</b> false
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;SHOW_WEEK_HEADER&quot;,{ value:false, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkBoolean } );

	<i>/**
	* True <b>if</b> the Calendar should show week row footers. False by <b>default</b>.
	* @config SHOW_WEEK_FOOTER
	* @type Boolean
	* @<b>default</b> false
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;SHOW_WEEK_FOOTER&quot;,{ value:false, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkBoolean } );

	<i>/**
	* True <b>if</b> the Calendar should suppress weeks that are not a part of the current month. False by <b>default</b>.
	* @config HIDE_BLANK_WEEKS
	* @type Boolean
	* @<b>default</b> false
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;HIDE_BLANK_WEEKS&quot;,{ value:false, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkBoolean } );

	<i>/**
	* The image that should be used <b>for</b> the left navigation arrow.
	* @config NAV_ARROW_LEFT
	* @type String
	* @<b>default</b> YAHOO.widget.Calendar.IMG_ROOT + &quot;us/tr/callt.gif&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;NAV_ARROW_LEFT&quot;,	{ value:YAHOO.widget.Calendar.IMG_ROOT + &quot;us/tr/callt.gif&quot;, handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The image that should be used <b>for</b> the left navigation arrow.
	* @config NAV_ARROW_RIGHT
	* @type String
	* @<b>default</b> YAHOO.widget.Calendar.IMG_ROOT + &quot;us/tr/calrt.gif&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;NAV_ARROW_RIGHT&quot;,	{ value:YAHOO.widget.Calendar.IMG_ROOT + &quot;us/tr/calrt.gif&quot;, handler:<b>this</b>.delegateConfig } );

	<i>// Locale properties</i>

	<i>/**
	* The short month labels <b>for</b> the current locale.
	* @config MONTHS_SHORT
	* @type String[]
	* @<b>default</b> [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;]
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MONTHS_SHORT&quot;,	{ value:[&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;], handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The long month labels <b>for</b> the current locale.
	* @config MONTHS_LONG
	* @type String[]
	* @<b>default</b> [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MONTHS_LONG&quot;,		{ value:[&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;], handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The 1-character weekday labels <b>for</b> the current locale.
	* @config WEEKDAYS_1CHAR
	* @type String[]
	* @<b>default</b> [&quot;S&quot;, &quot;M&quot;, &quot;T&quot;, &quot;W&quot;, &quot;T&quot;, &quot;F&quot;, &quot;S&quot;]
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;WEEKDAYS_1CHAR&quot;,	{ value:[&quot;S&quot;, &quot;M&quot;, &quot;T&quot;, &quot;W&quot;, &quot;T&quot;, &quot;F&quot;, &quot;S&quot;], handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The short weekday labels <b>for</b> the current locale.
	* @config WEEKDAYS_SHORT
	* @type String[]
	* @<b>default</b> [&quot;Su&quot;, &quot;Mo&quot;, &quot;Tu&quot;, &quot;We&quot;, &quot;Th&quot;, &quot;Fr&quot;, &quot;Sa&quot;]
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;WEEKDAYS_SHORT&quot;,	{ value:[&quot;Su&quot;, &quot;Mo&quot;, &quot;Tu&quot;, &quot;We&quot;, &quot;Th&quot;, &quot;Fr&quot;, &quot;Sa&quot;], handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The medium weekday labels <b>for</b> the current locale.
	* @config WEEKDAYS_MEDIUM
	* @type String[]
	* @<b>default</b> [&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;]
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;WEEKDAYS_MEDIUM&quot;,	{ value:[&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;], handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The long weekday labels <b>for</b> the current locale.
	* @config WEEKDAYS_LONG
	* @type String[]
	* @<b>default</b> [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;]
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;WEEKDAYS_LONG&quot;,	{ value:[&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;], handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The setting that determines which length of month labels should be used. Possible values are &quot;short&quot; and &quot;long&quot;.
	* @config LOCALE_MONTHS
	* @type String
	* @<b>default</b> &quot;long&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;LOCALE_MONTHS&quot;,	{ value:&quot;long&quot;, handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The setting that determines which length of weekday labels should be used. Possible values are &quot;1char&quot;, &quot;short&quot;, &quot;medium&quot;, and &quot;long&quot;.
	* @config LOCALE_WEEKDAYS
	* @type String
	* @<b>default</b> &quot;short&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;LOCALE_WEEKDAYS&quot;,	{ value:&quot;short&quot;, handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The value used to delimit individual dates <b>in</b> a date string passed to various Calendar functions.
	* @config DATE_DELIMITER
	* @type String
	* @<b>default</b> &quot;,&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;DATE_DELIMITER&quot;,		{ value:&quot;,&quot;, handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The value used to delimit date fields <b>in</b> a date string passed to various Calendar functions.
	* @config DATE_FIELD_DELIMITER
	* @type String
	* @<b>default</b> &quot;/&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;DATE_FIELD_DELIMITER&quot;,{ value:&quot;/&quot;, handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The value used to delimit date ranges <b>in</b> a date string passed to various Calendar functions.
	* @config DATE_RANGE_DELIMITER
	* @type String
	* @<b>default</b> &quot;-&quot;
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;DATE_RANGE_DELIMITER&quot;,{ value:&quot;-&quot;, handler:<b>this</b>.delegateConfig } );

	<i>/**
	* The position of the month <b>in</b> a month/year date string
	* @config MY_MONTH_POSITION
	* @type Number
	* @<b>default</b> 1
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MY_MONTH_POSITION&quot;,	{ value:1, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkNumber } );

	<i>/**
	* The position of the year <b>in</b> a month/year date string
	* @config MY_YEAR_POSITION
	* @type Number
	* @<b>default</b> 2
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MY_YEAR_POSITION&quot;,	{ value:2, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkNumber } );

	<i>/**
	* The position of the month <b>in</b> a month/day date string
	* @config MD_MONTH_POSITION
	* @type Number
	* @<b>default</b> 1
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MD_MONTH_POSITION&quot;,	{ value:1, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkNumber } );

	<i>/**
	* The position of the day <b>in</b> a month/year date string
	* @config MD_DAY_POSITION
	* @type Number
	* @<b>default</b> 2
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MD_DAY_POSITION&quot;,		{ value:2, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkNumber } );

	<i>/**
	* The position of the month <b>in</b> a month/day/year date string
	* @config MDY_MONTH_POSITION
	* @type Number
	* @<b>default</b> 1
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MDY_MONTH_POSITION&quot;,	{ value:1, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkNumber } );

	<i>/**
	* The position of the day <b>in</b> a month/day/year date string
	* @config MDY_DAY_POSITION
	* @type Number
	* @<b>default</b> 2
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MDY_DAY_POSITION&quot;,	{ value:2, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkNumber } );

	<i>/**
	* The position of the year <b>in</b> a month/day/year date string
	* @config MDY_YEAR_POSITION
	* @type Number
	* @<b>default</b> 3
	*/</i>
	<b>this</b>.cfg.addProperty(&quot;MDY_YEAR_POSITION&quot;,	{ value:3, handler:<b>this</b>.delegateConfig, validator:<b>this</b>.cfg.checkNumber } );

};

<i>/**
* Initializes CalendarGroup's built-<b>in</b> CustomEvents
* @method initEvents
*/</i>
YAHOO.widget.CalendarGroup.prototype.initEvents = <b>function</b>() {
	<b>var</b> me = <b>this</b>;

	<i>/**
	* Proxy subscriber to subscribe to the CalendarGroup's child Calendars' CustomEvents
	* @method sub
	* @private
	* @param {Function} fn	The <b>function</b> to subscribe to <b>this</b> CustomEvent
	* @param {Object}	obj	The CustomEvent's scope object
	* @param {Boolean}	bOverride	Whether or not to apply scope correction
	*/</i>
	<b>var</b> sub = <b>function</b>(fn, obj, bOverride) {
		<b>for</b> (<b>var</b> p=0;p&lt;me.pages.length;++p) {
			<b>var</b> cal = me.pages[p];
			cal[<b>this</b>.type + &quot;Event&quot;].subscribe(fn, obj, bOverride);
		}
	};

	<i>/**
	* Proxy unsubscriber to unsubscribe from the CalendarGroup's child Calendars' CustomEvents
	* @method unsub
	* @private
	* @param {Function} fn	The <b>function</b> to subscribe to <b>this</b> CustomEvent
	* @param {Object}	obj	The CustomEvent's scope object
	*/</i>
	<b>var</b> unsub = <b>function</b>(fn, obj) {
		<b>for</b> (<b>var</b> p=0;p&lt;me.pages.length;++p) {
			<b>var</b> cal = me.pages[p];
			cal[<b>this</b>.type + &quot;Event&quot;].unsubscribe(fn, obj);
		}
	};

	<i>/**
	* Fired before a selection is made
	* @event beforeSelectEvent
	*/</i>
	<b>this</b>.beforeSelectEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;beforeSelect&quot;);
	<b>this</b>.beforeSelectEvent.subscribe = sub; <b>this</b>.beforeSelectEvent.unsubscribe = unsub;

	<i>/**
	* Fired when a selection is made
	* @event selectEvent
	* @param {Array}	Array of Date field arrays <b>in</b> the format [YYYY, MM, DD].
	*/</i>
	<b>this</b>.selectEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;select&quot;);
	<b>this</b>.selectEvent.subscribe = sub; <b>this</b>.selectEvent.unsubscribe = unsub;

	<i>/**
	* Fired before a selection is made
	* @event beforeDeselectEvent
	*/</i>
	<b>this</b>.beforeDeselectEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;beforeDeselect&quot;);
	<b>this</b>.beforeDeselectEvent.subscribe = sub; <b>this</b>.beforeDeselectEvent.unsubscribe = unsub;

	<i>/**
	* Fired when a selection is made
	* @event deselectEvent
	* @param {Array}	Array of Date field arrays <b>in</b> the format [YYYY, MM, DD].
	*/</i>
	<b>this</b>.deselectEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;deselect&quot;);
	<b>this</b>.deselectEvent.subscribe = sub; <b>this</b>.deselectEvent.unsubscribe = unsub;

	<i>/**
	* Fired when the Calendar page is changed
	* @event changePageEvent
	*/</i>
	<b>this</b>.changePageEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;changePage&quot;);
	<b>this</b>.changePageEvent.subscribe = sub; <b>this</b>.changePageEvent.unsubscribe = unsub;

	<i>/**
	* Fired before the Calendar is rendered
	* @event beforeRenderEvent
	*/</i>
	<b>this</b>.beforeRenderEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;beforeRender&quot;);
	<b>this</b>.beforeRenderEvent.subscribe = sub; <b>this</b>.beforeRenderEvent.unsubscribe = unsub;

	<i>/**
	* Fired when the Calendar is rendered
	* @event renderEvent
	*/</i>
	<b>this</b>.renderEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;render&quot;);
	<b>this</b>.renderEvent.subscribe = sub; <b>this</b>.renderEvent.unsubscribe = unsub;

	<i>/**
	* Fired when the Calendar is reset
	* @event resetEvent
	*/</i>
	<b>this</b>.resetEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;reset&quot;);
	<b>this</b>.resetEvent.subscribe = sub; <b>this</b>.resetEvent.unsubscribe = unsub;

	<i>/**
	* Fired when the Calendar is cleared
	* @event clearEvent
	*/</i>
	<b>this</b>.clearEvent = <b>new</b> YAHOO.util.CustomEvent(&quot;clear&quot;);
	<b>this</b>.clearEvent.subscribe = sub; <b>this</b>.clearEvent.unsubscribe = unsub;

};

<i>/**
* The <b>default</b> Config handler <b>for</b> the &quot;pages&quot; property
* @method configPages
* @param {String} type	The CustomEvent type (usually the property name)
* @param {Object[]}	args	The CustomEvent arguments. For configuration handlers, args[0] will equal the newly applied value <b>for</b> the property.
* @param {Object} obj	The scope object. For configuration handlers, <b>this</b> will usually equal the owner.
*/</i>
YAHOO.widget.CalendarGroup.prototype.configPages = <b>function</b>(type, args, obj) {
	<b>var</b> pageCount = args[0];

	<b>for</b> (<b>var</b> p=0;p&lt;pageCount;++p) {
		<b>var</b> calId = <b>this</b>.id + &quot;_&quot; + p;
		<b>var</b> calContainerId = <b>this</b>.containerId + &quot;_&quot; + p;

		<b>var</b> childConfig = <b>this</b>.cfg.getConfig();
		childConfig.close = false;
		childConfig.title = false;

		<b>var</b> cal = <b>this</b>.constructChild(calId, calContainerId, childConfig);
		<b>var</b> caldate = cal.cfg.getProperty(&quot;pagedate&quot;);
		caldate.setMonth(caldate.getMonth()+p);
		cal.cfg.setProperty(&quot;pagedate&quot;, caldate);

		YAHOO.util.Dom.removeClass(cal.oDomContainer, <b>this</b>.Style.CSS_SINGLE);
		YAHOO.util.Dom.addClass(cal.oDomContainer, &quot;groupcal&quot;);

		<b>if</b> (p===0) {
			YAHOO.util.Dom.addClass(cal.oDomContainer, &quot;first&quot;);
		}

		<b>if</b> (p==(pageCount-1)) {
			YAHOO.util.Dom.addClass(cal.oDomContainer, &quot;last&quot;);
		}

		cal.parent = <b>this</b>;
		cal.index = p;

		<b>this</b>.pages[<b>this</b>.pages.length] = cal;
	}
};

<i>/**
* The <b>default</b> Config handler <b>for</b> the &quot;pagedate&quot; property
* @method configPageDate
* @param {String} type	The CustomEvent type (usually the property name)
* @param {Object[]}	args	The CustomEvent arguments. For configuration handlers, args[0] will equal the newly applied value <b>for</b> the property.
* @param {Object} obj	The scope object. For configuration handlers, <b>this</b> will usually equal the owner.
*/</i>
YAHOO.widget.CalendarGroup.prototype.configPageDate = <b>function</b>(type, args, obj) {
	<b>var</b> val = args[0];

	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.cfg.setProperty(&quot;pagedate&quot;, val);
		<b>var</b> calDate = cal.cfg.getProperty(&quot;pagedate&quot;);
		calDate.setMonth(calDate.getMonth()+p);
	}
};

<i>/**
* Delegates a configuration property to the CustomEvents associated <b>with</b> the CalendarGroup's children
* @method delegateConfig
* @param {String} type	The CustomEvent type (usually the property name)
* @param {Object[]}	args	The CustomEvent arguments. For configuration handlers, args[0] will equal the newly applied value <b>for</b> the property.
* @param {Object} obj	The scope object. For configuration handlers, <b>this</b> will usually equal the owner.
*/</i>
YAHOO.widget.CalendarGroup.prototype.delegateConfig = <b>function</b>(type, args, obj) {
	<b>var</b> val = args[0];
	<b>var</b> cal;

	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;p++) {
		cal = <b>this</b>.pages[p];
		cal.cfg.setProperty(type, val);
	}
};


<i>/**
* Adds a <b>function</b> to all child Calendars within <b>this</b> CalendarGroup.
* @method setChildFunction
* @param {String}		fnName		The name of the <b>function</b>
* @param {Function}		fn			The <b>function</b> to apply to each Calendar page object
*/</i>
YAHOO.widget.CalendarGroup.prototype.setChildFunction = <b>function</b>(fnName, fn) {
	<b>var</b> pageCount = <b>this</b>.cfg.getProperty(&quot;pages&quot;);

	<b>for</b> (<b>var</b> p=0;p&lt;pageCount;++p) {
		<b>this</b>.pages[p][fnName] = fn;
	}
};

<i>/**
* Calls a <b>function</b> within all child Calendars within <b>this</b> CalendarGroup.
* @method callChildFunction
* @param {String}		fnName		The name of the <b>function</b>
* @param {Array}		args		The arguments to pass to the <b>function</b>
*/</i>
YAHOO.widget.CalendarGroup.prototype.callChildFunction = <b>function</b>(fnName, args) {
	<b>var</b> pageCount = <b>this</b>.cfg.getProperty(&quot;pages&quot;);

	<b>for</b> (<b>var</b> p=0;p&lt;pageCount;++p) {
		<b>var</b> page = <b>this</b>.pages[p];
		<b>if</b> (page[fnName]) {
			<b>var</b> fn = page[fnName];
			fn.call(page, args);
		}
	}
};

<i>/**
* Constructs a child calendar. This method can be overridden <b>if</b> a subclassed version of the <b>default</b>
* calendar is to be used.
* @method constructChild
* @param {String}	id			The id of the table element that will represent the calendar widget
* @param {String}	containerId	The id of the container div element that will wrap the calendar table
* @param {Object}	config		The configuration object containing the Calendar's arguments
* @<b>return</b> {YAHOO.widget.Calendar}	The YAHOO.widget.Calendar instance that is constructed
*/</i>
YAHOO.widget.CalendarGroup.prototype.constructChild = <b>function</b>(id,containerId,config) {
	<b>var</b> container = document.getElementById(containerId);
	<b>if</b> (! container) {
		container = document.createElement(&quot;div&quot;);
		container.id = containerId;
		<b>this</b>.oDomContainer.appendChild(container);
	}
	<b>return</b> new YAHOO.widget.Calendar(id,containerId,config);
};


<i>/**
* Sets the calendar group's month explicitly. This month will be set into the first
* @method setMonth
* page of the multi-page calendar, and all other months will be iterated appropriately.
* @param {Number}	month		The numeric month, from 0 (January) to 11 (December)
*/</i>
YAHOO.widget.CalendarGroup.prototype.setMonth = <b>function</b>(month) {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.setMonth(month+p);
	}
};

<i>/**
* Sets the calendar group's year explicitly. This year will be set into the first
* @method setYear
* page of the multi-page calendar, and all other months will be iterated appropriately.
* @param {Number}	year		The numeric 4-digit year
*/</i>
YAHOO.widget.CalendarGroup.prototype.setYear = <b>function</b>(year) {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		<b>var</b> pageDate = cal.cfg.getProperty(&quot;pageDate&quot;);

		<b>if</b> ((pageDate.getMonth()+1) == 1 &amp;&amp; p&gt;0) {
			year+=1;
		}
		cal.setYear(year);
	}
};
<i>/**
* Calls the render <b>function</b> of all child calendars within the group.
* @method render
*/</i>
YAHOO.widget.CalendarGroup.prototype.render = <b>function</b>() {
	<b>this</b>.renderHeader();
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.render();
	}
	<b>this</b>.renderFooter();
};

<i>/**
* Selects a date or a collection of dates on the current calendar. This method, by <b>default</b>,
* does not call the render method explicitly. Once selection has completed, render must be
* called <b>for</b> the changes to be reflected visually.
* @method select
* @param	{String/Date/Date[]}	date	The date string of dates to select <b>in</b> the current calendar. Valid formats are
*								individual date(s) (12/24/2005,12/26/2005) or date range(s) (12/24/2005-1/1/2006).
*								Multiple comma-delimited dates can also be passed to <b>this</b> method (12/24/2005,12/11/2005-12/13/2005).
*								This method can also take a JavaScript Date object or an array of Date objects.
* @<b>return</b>	{Date[]}			Array of JavaScript Date objects representing all individual dates that are currently selected.
*/</i>
YAHOO.widget.CalendarGroup.prototype.select = <b>function</b>(date) {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.select(date);
	}
	<b>return</b> this.getSelectedDates();
};

<i>/**
* Selects a date on the current calendar by referencing the index of the cell that should be selected.
* This method is used to easily select a single cell (usually <b>with</b> a mouse click) without having to <b>do</b>
* a full render. The selected style is applied to the cell directly.
* @method selectCell
* @param	{Number}	cellIndex	The index of the cell to select <b>in</b> the current calendar.
* @<b>return</b>	{Date[]}	Array of JavaScript Date objects representing all individual dates that are currently selected.
*/</i>
YAHOO.widget.CalendarGroup.prototype.selectCell = <b>function</b>(cellIndex) {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.selectCell(cellIndex);
	}
	<b>return</b> this.getSelectedDates();
};

<i>/**
* Deselects a date or a collection of dates on the current calendar. This method, by <b>default</b>,
* does not call the render method explicitly. Once deselection has completed, render must be
* called <b>for</b> the changes to be reflected visually.
* @method deselect
* @param	{String/Date/Date[]}	date	The date string of dates to deselect <b>in</b> the current calendar. Valid formats are
*								individual date(s) (12/24/2005,12/26/2005) or date range(s) (12/24/2005-1/1/2006).
*								Multiple comma-delimited dates can also be passed to <b>this</b> method (12/24/2005,12/11/2005-12/13/2005).
*								This method can also take a JavaScript Date object or an array of Date objects.
* @<b>return</b>	{Date[]}			Array of JavaScript Date objects representing all individual dates that are currently selected.
*/</i>
YAHOO.widget.CalendarGroup.prototype.deselect = <b>function</b>(date) {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.deselect(date);
	}
	<b>return</b> this.getSelectedDates();
};

<i>/**
* Deselects all dates on the current calendar.
* @method deselectAll
* @<b>return</b> {Date[]}		Array of JavaScript Date objects representing all individual dates that are currently selected.
*						Assuming that <b>this</b> function executes properly, the <b>return</b> value should be an empty array.
*						However, the empty array is returned <b>for</b> the sake of being able to check the selection status
*						of the calendar.
*/</i>
YAHOO.widget.CalendarGroup.prototype.deselectAll = <b>function</b>() {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.deselectAll();
	}
	<b>return</b> this.getSelectedDates();
};

<i>/**
* Deselects a date on the current calendar by referencing the index of the cell that should be deselected.
* This method is used to easily deselect a single cell (usually <b>with</b> a mouse click) without having to <b>do</b>
* a full render. The selected style is removed from the cell directly.
* @method deselectCell
* @param	{Number}	cellIndex	The index of the cell to deselect <b>in</b> the current calendar.
* @<b>return</b>	{Date[]}	Array of JavaScript Date objects representing all individual dates that are currently selected.
*/</i>
YAHOO.widget.CalendarGroup.prototype.deselectCell = <b>function</b>(cellIndex) {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.deselectCell(cellIndex);
	}
	<b>return</b> this.getSelectedDates();
};

<i>/**
* Resets the calendar widget to the originally selected month and year, and
* sets the calendar to the initial selection(s).
* @method reset
*/</i>
YAHOO.widget.CalendarGroup.prototype.reset = <b>function</b>() {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.reset();
	}
};

<i>/**
* Clears the selected dates <b>in</b> the current calendar widget and sets the calendar
* to the current month and year.
* @method clear
*/</i>
YAHOO.widget.CalendarGroup.prototype.clear = <b>function</b>() {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.clear();
	}
};

<i>/**
* Navigates to the next month page <b>in</b> the calendar widget.
* @method nextMonth
*/</i>
YAHOO.widget.CalendarGroup.prototype.nextMonth = <b>function</b>() {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.nextMonth();
	}
};

<i>/**
* Navigates to the previous month page <b>in</b> the calendar widget.
* @method previousMonth
*/</i>
YAHOO.widget.CalendarGroup.prototype.previousMonth = <b>function</b>() {
	<b>for</b> (<b>var</b> p=<b>this</b>.pages.length-1;p&gt;=0;--p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.previousMonth();
	}
};

<i>/**
* Navigates to the next year <b>in</b> the currently selected month <b>in</b> the calendar widget.
* @method nextYear
*/</i>
YAHOO.widget.CalendarGroup.prototype.nextYear = <b>function</b>() {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.nextYear();
	}
};

<i>/**
* Navigates to the previous year <b>in</b> the currently selected month <b>in</b> the calendar widget.
* @method previousYear
*/</i>
YAHOO.widget.CalendarGroup.prototype.previousYear = <b>function</b>() {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.previousYear();
	}
};


<i>/**
* Gets the list of currently selected dates from the calendar.
* @<b>return</b>			An array of currently selected JavaScript Date objects.
* @type Date[]
*/</i>
YAHOO.widget.CalendarGroup.prototype.getSelectedDates = <b>function</b>() {
	<b>var</b> returnDates = [];
	<b>var</b> selected = <b>this</b>.cfg.getProperty(&quot;selected&quot;);

	<b>for</b> (<b>var</b> d=0;d&lt;selected.length;++d) {
		<b>var</b> dateArray = selected[d];

		<b>var</b> date = <b>new</b> Date(dateArray[0],dateArray[1]-1,dateArray[2]);
		returnDates.push(date);
	}

	returnDates.sort( <b>function</b>(a,b) { <b>return</b> a-b; } );
	<b>return</b> returnDates;
};

<i>/**
* Adds a renderer to the render stack. The <b>function</b> reference passed to <b>this</b> method will be executed
* when a date cell matches the conditions specified <b>in</b> the date string <b>for</b> this renderer.
* @method addRenderer
* @param	{String}	sDates		A date string to associate <b>with</b> the specified renderer. Valid formats
*									include date (12/24/2005), month/day (12/24), and range (12/1/2004-1/1/2005)
* @param	{Function}	fnRender	The <b>function</b> executed to render cells that match the render rules <b>for</b> this renderer.
*/</i>
YAHOO.widget.CalendarGroup.prototype.addRenderer = <b>function</b>(sDates, fnRender) {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.addRenderer(sDates, fnRender);
	}
};

<i>/**
* Adds a month to the render stack. The <b>function</b> reference passed to <b>this</b> method will be executed
* when a date cell matches the month passed to <b>this</b> method.
* @method addMonthRenderer
* @param	{Number}	month		The month (1-12) to associate <b>with</b> this renderer
* @param	{Function}	fnRender	The <b>function</b> executed to render cells that match the render rules <b>for</b> this renderer.
*/</i>
YAHOO.widget.CalendarGroup.prototype.addMonthRenderer = <b>function</b>(month, fnRender) {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.addMonthRenderer(month, fnRender);
	}
};

<i>/**
* Adds a weekday to the render stack. The <b>function</b> reference passed to <b>this</b> method will be executed
* when a date cell matches the weekday passed to <b>this</b> method.
* @method addWeekdayRenderer
* @param	{Number}	weekday		The weekday (0-6) to associate <b>with</b> this renderer
* @param	{Function}	fnRender	The <b>function</b> executed to render cells that match the render rules <b>for</b> this renderer.
*/</i>
YAHOO.widget.CalendarGroup.prototype.addWeekdayRenderer = <b>function</b>(weekday, fnRender) {
	<b>for</b> (<b>var</b> p=0;p&lt;<b>this</b>.pages.length;++p) {
		<b>var</b> cal = <b>this</b>.pages[p];
		cal.addWeekdayRenderer(weekday, fnRender);
	}
};

<i>/**
* Renders the header <b>for</b> the CalendarGroup.
* @method renderHeader
*/</i>
YAHOO.widget.CalendarGroup.prototype.renderHeader = <b>function</b>() {};

<i>/**
* Renders a footer <b>for</b> the 2-up calendar container. By <b>default</b>, <b>this</b> method is
* unimplemented.
* @method renderFooter
*/</i>
YAHOO.widget.CalendarGroup.prototype.renderFooter = <b>function</b>() {};

<i>/**
* Adds the designated number of months to the current calendar month, and sets the current
* calendar page date to the <b>new</b> month.
* @method addMonths
* @param {Number}	count	The number of months to add to the current calendar
*/</i>
YAHOO.widget.CalendarGroup.prototype.addMonths = <b>function</b>(count) {
	<b>this</b>.callChildFunction(&quot;addMonths&quot;, count);
};


<i>/**
* Subtracts the designated number of months from the current calendar month, and sets the current
* calendar page date to the <b>new</b> month.
* @method subtractMonths
* @param {Number}	count	The number of months to subtract from the current calendar
*/</i>
YAHOO.widget.CalendarGroup.prototype.subtractMonths = <b>function</b>(count) {
	<b>this</b>.callChildFunction(&quot;subtractMonths&quot;, count);
};

<i>/**
* Adds the designated number of years to the current calendar, and sets the current
* calendar page date to the <b>new</b> month.
* @method addYears
* @param {Number}	count	The number of years to add to the current calendar
*/</i>
YAHOO.widget.CalendarGroup.prototype.addYears = <b>function</b>(count) {
	<b>this</b>.callChildFunction(&quot;addYears&quot;, count);
};

<i>/**
* Subtcats the designated number of years from the current calendar, and sets the current
* calendar page date to the <b>new</b> month.
* @method subtractYears
* @param {Number}	count	The number of years to subtract from the current calendar
*/</i>
YAHOO.widget.CalendarGroup.prototype.subtractYears = <b>function</b>(count) {
	<b>this</b>.callChildFunction(&quot;subtractYears&quot;, count);
};

<i>/**
* CSS class representing the container <b>for</b> the calendar
* @property YAHOO.widget.CalendarGroup.CSS_CONTAINER
* @static
* @final
* @type String
*/</i>
YAHOO.widget.CalendarGroup.CSS_CONTAINER = &quot;yui-calcontainer&quot;;

<i>/**
* CSS class representing the container <b>for</b> the calendar
* @property YAHOO.widget.CalendarGroup.CSS_MULTI_UP
* @static
* @final
* @type String
*/</i>
YAHOO.widget.CalendarGroup.CSS_MULTI_UP = &quot;multi&quot;;

<i>/**
* CSS class representing the title <b>for</b> the 2-up calendar
* @property YAHOO.widget.CalendarGroup.CSS_2UPTITLE
* @static
* @final
* @type String
*/</i>
YAHOO.widget.CalendarGroup.CSS_2UPTITLE = &quot;title&quot;;

<i>/**
* CSS class representing the close icon <b>for</b> the 2-up calendar
* @property YAHOO.widget.CalendarGroup.CSS_2UPCLOSE
* @static
* @final
* @type String
*/</i>
YAHOO.widget.CalendarGroup.CSS_2UPCLOSE = &quot;close-icon&quot;;

YAHOO.augment(YAHOO.widget.CalendarGroup, YAHOO.widget.Calendar, &quot;buildDayLabel&quot;,
																 &quot;buildMonthLabel&quot;,
																 &quot;renderOutOfBoundsDate&quot;,
																 &quot;renderRowHeader&quot;,
																 &quot;renderRowFooter&quot;,
																 &quot;renderCellDefault&quot;,
																 &quot;styleCellDefault&quot;,
																 &quot;renderCellStyleHighlight1&quot;,
																 &quot;renderCellStyleHighlight2&quot;,
																 &quot;renderCellStyleHighlight3&quot;,
																 &quot;renderCellStyleHighlight4&quot;,
																 &quot;renderCellStyleToday&quot;,
																 &quot;renderCellStyleSelected&quot;,
																 &quot;renderCellNotThisMonth&quot;,
																 &quot;renderBodyCellRestricted&quot;,
																 &quot;initStyles&quot;,
																 &quot;configTitle&quot;,
																 &quot;configClose&quot;,
																 &quot;hide&quot;,
																 &quot;show&quot;,
																 &quot;browser&quot;);

<i>/**
* Returns a string representation of the object.
* @method toString
* @<b>return</b> {String}	A string representation of the CalendarGroup object.
*/</i>
YAHOO.widget.CalendarGroup.prototype.toString = <b>function</b>() {
	<b>return</b> &quot;CalendarGroup &quot; + <b>this</b>.id;
};

YAHOO.widget.CalGrp = YAHOO.widget.CalendarGroup;

<i>/**
* @class YAHOO.widget.Calendar2up
* @extends YAHOO.widget.CalendarGroup
* @deprecated The old Calendar2up class is no longer necessary, since CalendarGroup renders <b>in</b> a 2up view by <b>default</b>.
*/</i>
YAHOO.widget.Calendar2up = <b>function</b>(id, containerId, config) {
	<b>this</b>.init(id, containerId, config);
};

YAHOO.extend(YAHOO.widget.Calendar2up, YAHOO.widget.CalendarGroup);

<i>/**
* @deprecated The old Calendar2up class is no longer necessary, since CalendarGroup renders <b>in</b> a 2up view by <b>default</b>.
*/</i>
YAHOO.widget.Cal2up = YAHOO.widget.Calendar2up;</code></pre><hr><div style="font-size:10px;text-align:center;color:gray;">yui-ext - Copyright &copy; 2006 Jack Slocum.  |
    Yahoo! UI - Copyright &copy; 2006 Yahoo! Inc.<br />All rights reserved.</div>
    </body></html>